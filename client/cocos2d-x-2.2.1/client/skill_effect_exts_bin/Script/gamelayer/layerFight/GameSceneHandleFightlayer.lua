-------- 游戏Running详细处理--------g_CurLevelIndex = 1		--当前关卡索引local touchBeginPoint = nillocal mIsPlayAnimation = false;		--在播放动画的时候 禁止用所有事件local mIsGameOver = false---   30个格子的数据表 与点击事件相关   ---	  staus 初始化格子状态 用于区分点击事件类型--	  hidden 隐藏精灵--	  isMasked 是否被遮罩local m_GildEvent = {}  -- 30格的事件数组local mMonsterTable = {}--怪物表local mBuffInfoTable = {}local mHaloTable = {} local mMonsterAutoStepCount = 0--玩家基本属性表local mPlayerAttribute = {}GameSceneHandleFight = {}local m_bIsPlayerFirtst = false -- 当前回合 是否玩家先手local mCurClickMonsterPos = -1  -- 当前攻击怪物的位置function ClearFightDate(mapdate)	mIsPlayAnimation = false	mMonsterTable = {}	mBuffInfoTable = {}	mHaloTable = {}	m_GildEvent = mapdate	return mapdateend-- 打开遮罩 GridId：地块ID isRecursive 是否递归function OpenMask(GridId,isRecursive)	if(GridId <= 30 and GridId >= 1) then		local tmxlayer = getTmxMapBackground():layerNamed("layer1")		tileCoord = ccp(getPosByGridID(GridId))		local sprite = tmxlayer:tileAt(tileCoord);				if m_GildEvent[GridId].isMasked  == true then 			FightAnimation_fadeOut(sprite)			m_GildEvent[GridId].isMasked = false			--sprite:setVisible(false)		end		--如果翻开的是障碍 周围的就不翻开？？		if m_GildEvent[GridId].hidden == g_Const_Sprite.Type.barrier then			print{"翻开障碍~~~~~~~~~~~~~~",GridId}			return		end				if(isRecursive == true)	then			if (GridId )%5 ~= 0 then				OpenMask(GridId+1,false)			end			if (GridId - 1)%5 ~= 0 then	--最左边？				OpenMask(GridId-1,false)			end			OpenMask(GridId+5,false)			OpenMask(GridId-5,false)		end	endend-- 打开"X"限制 GridId：地块ID(点击格子出现怪物触发)function OpenXLimit(GridId,isRecursive)	if(GridId <= 30 and GridId >= 1) then		--print("getModifySprite Targer:",GridId)		local ModifySprite = getModifyNodeRoot():getChildByTag(GridId+mModifyMask)		if(isRecursive == true) then			ModifySprite:setVisible(false)		elseif (isRecursive == false) and m_GildEvent[GridId].staus == g_Const_Sprite.Type.gird then				ModifySprite:setVisible(true)				FightAnimation_openX(ModifySprite)			m_GildEvent[GridId].staus = g_Const_Sprite.Type.limit		end		if(isRecursive == true)	then			if (GridId )%5 ~= 0 then	--最右边？				OpenXLimit(GridId-4,false)				OpenXLimit(GridId+1,false)				OpenXLimit(GridId+6,false)			end			if (GridId - 1)%5 ~= 0 then	--最左边？				OpenXLimit(GridId+4,false)				OpenXLimit(GridId-1,false)				OpenXLimit(GridId-6,false)			end			OpenXLimit(GridId+5,false)			OpenXLimit(GridId-5,false)		end	endend-- 判断当前位置 是不是 在怪物周围local function isMonsterRound(monsterPos,_id) 	if (monsterPos )%5 ~= 0 then	--最右边		if (_id == monsterPos-4) or (_id == monsterPos+1) or (_id == monsterPos+6) then			return true		end	end	if (monsterPos - 1)%5 ~= 0 then	--最左边		if (_id == monsterPos+4) or (_id == monsterPos-1) or (_id == monsterPos-6) then			return true		end	end	if (_id == monsterPos+5) or (_id == monsterPos-5) then 		return true	end	return falseend-----怪物死了触发 周围“X” 关闭local function CloseXLimitSignal(GridId)	-- 判断 XX是否能关闭	local function isClosbleX(id) 		for k1,v1 in pairs(m_GildEvent)  do			if(v1.staus ==  g_Const_Sprite.Type.monster) then				if v1.otherDate.attack_type ~= 1 then --主动怪没有XX的概念					--OpenXLimit(k1,true)						--判断怪的是不是属于存活怪的周围					if isMonsterRound(k1,id) ==  true then 						return false					end				end			end		end		return true	end	if(GridId <= 30 and GridId >= 1) then		--print("getModifySprite Targer:",GridId+mModifyMask)		local ModifySprite = getModifyNodeRoot():getChildByTag(GridId+mModifyMask)		if m_GildEvent[GridId].staus == g_Const_Sprite.Type.limit then			if isClosbleX(GridId) then				--ModifySprite:setVisible(false)				FightAnimation_closeX(ModifySprite)				m_GildEvent[GridId].staus = g_Const_Sprite.Type.gird			end					end	endend--关闭"X" 单怪物给击杀时 被触发 function CloseXLimit(GridId)	--if m_GildEvent[GridId].otherDate.attack_type == 1 then		--return	--end	if (GridId )%5 ~= 0 then	--最右边？		CloseXLimitSignal(GridId-4)		CloseXLimitSignal(GridId+1)		CloseXLimitSignal(GridId+6)	end	if (GridId - 1)%5 ~= 0 then	--最左边？		CloseXLimitSignal(GridId+4)		CloseXLimitSignal(GridId-1)		CloseXLimitSignal(GridId-6)	end	CloseXLimitSignal(GridId+5)	CloseXLimitSignal(GridId-5)end-- 对道具点击的事件处理 PropType"预留道具类型"local function HandleOnClickProp(layerid,PropType)	FightDateCache.getItemInGameScene(m_GildEvent[layerid].otherDate.dropout)	--拾取道具数据逻辑	local Itemnode = g_sceneRoot:getChildByTag(layerid+mSpriteMask)	FightAnimation_moveItem(Itemnode)		local kuLou = CCSprite:create("monsterdeath.png")	kuLou:setAnchorPoint(ccp(0,0));	kuLou:setPosition(getTmxMapBackground():convertToWorldSpace(ccp( getRealSpritePosByGridId(layerid) )));	g_sceneRoot:addChild(kuLou,g_Const_GameLayer.sceneChildLayer.sprite+layerid);	kuLou:runAction(CCFadeIn:create(0.3))	FightDateCache.setcurReward("baoxiang",1)	GameUiLayer.updateBoxNum()	m_GildEvent[layerid].staus = g_Const_Sprite.Type.background  -- 拾取道具end-- 对没开的格子点击处理  参数 2：openType:打开类型 "RelaOpened" :关联怪模式被打开local function HandleOnClickGrid(layerid,openType)		local sprite = getGridNodeRoot():getChildByTag(layerid)	sprite:setVisible(false)	FightDateCache.ConductCheck(layerid,1,nil) --testCode	OpenMask(layerid,true)	local effect = createAnimation_signal("shouchuang_%03d.png",8,0.1)		--播放破坏箱子特效	effect:setPosition(getTmxMapBackground():convertToWorldSpace(ccp( getRealSpritePosByGridId(layerid) )));	effect:setAnchorPoint(ccp(0.2,0.3));	g_sceneRoot:addChild(effect,g_Const_GameLayer.sceneChildLayer.effect);		if openType ~= "RelaOpened" then		FightDateCache.Handle_mNextRound(Handle_NextRoundMapRender)	endend--刷新玩家与所有怪物属性function refreshAllArrView()	ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)	for key, element in pairs(mMonsterTable) do		ModelMonster.updateDate(element.detailArr, element.restoreArr)	endend--检测是否所有buff特效播放完毕function buffStepEnd()	mMonsterAutoStepCount = mMonsterAutoStepCount - 1	if mMonsterAutoStepCount <= 0 then		mMonsterAutoStepCount = 100000		print("all buff effect end")		mIsPlayAnimation = false		monsterAutoPlay()	endend--怪物主动攻击或使用技能function monsterAutoPlay()	print("monsterAutoPlay")	for key, element in pairs(mMonsterTable) do		local skill_cd = GameSkillMgr.getSkillCD(element.skillID)		if element.autoPlayCount > 0 then			element.autoPlayCount = 0			if element.detailArr.attack_type == 1 then--怪物主动攻击				monsterNormalAttack(element.sprite, "monsterInitiativeAttack")			elseif skill_cd > 0 and element.skillID > 0 and element.skillCDCount >= skill_cd then--怪物主动技能				print("monster use skill")				monsterUseSkill(element.sprite, element.skillID, "monsterUseSkill")				element.skillCDCount = 0			end			element.detailArr.skillCDProgress = element.skillCDCount / skill_cd			ModelMonster.updateDate(element.detailArr, element.restoreArr)			break		end	endend-- 每过一回合的处理 --function Handle_NextRoundMapRender()	mMonsterAutoStepCount = 0	mIsPlayAnimation = true		mPlayerAttribute.haloStepCount = 1	--怪物回合计数++	for key, element in pairs(mMonsterTable) do		--主动怪被攻击后,下回合不再主动攻击		if element.autoPlayCount == -1 then			if element.detailArr.attack_type == 1 then				element.autoPlayCount = 0			else				element.autoPlayCount = 1			end		else			element.autoPlayCount = 1		end				element.haloStepCount = 1				if element.skillID > 0 then				--是否cd被恢复到最大值			local skill_cd = GameSkillMgr.getSkillCD(element.skillID)			--是否是主动技能			if skill_cd > 0 then				local isMaxCD, statusValue = isExistModifyAttribute(element.sprite, "max_cd")				if isMaxCD then					element.skillCDCount = 0				else					--是否被沉默					local isSilenced, silencedValue = isExistModifyAttribute(element.sprite, "silenced")					if isSilenced == false then						element.skillCDCount = element.skillCDCount + 1					end				end								local skill_cd = GameSkillMgr.getSkillCD(element.skillID)				element.detailArr.skillCDProgress = element.skillCDCount / skill_cd				print("element.detailArr.skillCDProgress.."..element.detailArr.skillCDProgress)				if element.detailArr.skillCDProgress > 1.0 then					element.detailArr.skillCDProgress = 1.0				end			else				element.detailArr.skillCDProgress = nil			end		end		ModelMonster.updateDate(element.detailArr, element.restoreArr)	end		--恢复玩家和怪物的基本属性值	restorePlayerArr()	for key, element in pairs(mMonsterTable) do		restoreMonsterArr(element)	end		--先处理怪物与玩家buff状态	buffStep()	hexStep()	haloStep()	buffModifedTargetAttribute()		--刷新属性值	ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)	for key, element in pairs(mMonsterTable) do		ModelMonster.updateDate(element.detailArr, element.restoreArr)	end		local skillStepName = "normal"		--玩家是否不可操作	local isUncontrollable, uncontrollableValue = isExistModifyAttribute(ModelPlayer:getPlayerNode(), "uncontrollable")	if isUncontrollable then		skillStepName = "uncontrollable"	else		--玩家是否cd被恢复到最大值		local isMaxCD, statusValue = isExistModifyAttribute(ModelPlayer:getPlayerNode(), "max_cd")		if isMaxCD then			skillStepName = "max_cd"		else			--是否被沉默			local isSilenced, silencedValue = isExistModifyAttribute(ModelPlayer:getPlayerNode(), "silenced")			if isSilenced then				skillStepName = "silenced"			end		end	end	GameSkillMgr.step(skillStepName)	buffStepEnd()endfunction gameOverJudge()	local bRet = true	if mPlayerAttribute.life > 0 then		bRet = false	end		if bRet then		mPlayerAttribute.life = 0		ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)		if  CopyDateCache.GameType == "jjc" then --如果是竞技 			FightDateCache.HandleGameSettle(2)		--竞技场挑战 失败			return nil 		else			UIManager.push("UI_FightFailed")                       -- 进入战斗失败界面		end	end	return bRetend------先手判断function SenteJudge(monsterDetailArr)	local Ret = false;	local K_speed = LogicTable.getGameDateTable().speed + 0		--速度常量	local monsterSpeed = monsterDetailArr.speed	local playerSpeed = mPlayerAttribute.speed	--【攻击方速度值 + random（攻击方速度值 * N%）】-【（被击方速度值 + random（被击方速度值 * N%）】	if (playerSpeed + math.random(0,playerSpeed*K_speed)) - ( monsterSpeed + math.random(0,monsterSpeed*K_speed) ) > 0 then		print("玩家先手")		Ret = true	else 		print("怪先手")	end	return Retend-- 功能:伤害类型判断-- 参数:1： 攻击者命中 2：攻击者暴击 3：防御者闪避 4:防御者韧性-- 返回:"miss" 闪避  "crit"暴击  "hit" 普通攻击function AtkTypeJudge(atker_hit_ratio,atker_critical_ratio,def_miss_ratio,def_tenacity)	--print(atker_hit_ratio,atker_critical_ratio,def_miss_ratio,def_tenacity)	local function Lv_To_Ration(Lv)		local ratio = 0		ratio = Lv/(Lv + 100)/2.5		return math.floor(ratio*100 +0.5)	end	atker_hit_ratio = Lv_To_Ration(atker_hit_ratio)	atker_critical_ratio = Lv_To_Ration(atker_critical_ratio)	def_miss_ratio = Lv_To_Ration(def_miss_ratio)	def_tenacity = Lv_To_Ration(def_tenacity)	--闪避率=（1-攻方命中率）*受方闪避率	local miss_ratio = ( (100 - atker_hit_ratio)*def_miss_ratio )/100	--暴击率=（1-受方韧性率）*攻方暴击率	--print("miss_ratio",miss_ratio)	local crit_ratio = ((100 - def_tenacity)*atker_critical_ratio )/100	--print("crit_ratio",crit_ratio)	local hit_ratio = 100 - (miss_ratio + crit_ratio)	--print("hit_ratio",hit_ratio)	local curRandom = math.random(1,100)	print("miss_ratio",miss_ratio,"crit_ratio",crit_ratio,"hit_ratio",hit_ratio)	print("随机数",curRandom)	if curRandom <= miss_ratio then 		return "miss"	elseif (curRandom > miss_ratio and curRandom < (crit_ratio+miss_ratio) )then 		FightAnimation_Crit(g_sceneRoot)  -- 暴击动画		return "crit"	else		return "hit"	end	print("随机数 不在范围内？有问题 ?再优化 圆桌算法？")	return "hit"end--- 功能： 计算伤害--- 参数： DamageType:伤害类型(string)  atk:攻击者攻击（number） Specialskills：附加技能加成（策划文档 未给 暂时nil）--- 返回： 最终伤害值local function attackDamageCalculation(DamageType,atk)	--伤害=基础攻击*（1+伤害加成）*（1-减伤），暴击时伤害翻倍，格挡时伤害减半，	local finalDp = atk	if DamageType == "crit" then 		finalDp = finalDp + finalDp	end	finalDp = finalDp + 0	if finalDp < 0 then		finalDp = 0	end	return finalDp	end--怪物掉血计算local function monsterDropBlood(sprite, monsterDetailArr)	--伤害类型	local DamageType = AtkTypeJudge(mPlayerAttribute.hit_ratio, mPlayerAttribute.critical_ratio, monsterDetailArr.miss_ratio, monsterDetailArr.tenacity)	local dp = attackDamageCalculation(DamageType, mPlayerAttribute.atk)	cclog("伤害类型：", DamageType,"造成伤害",dp)	if DamageType ~= "miss" then		--怪物是否伤害减免判定		local isDamageReduction, statusValue = isExistModifyAttribute(sprite, "damage_reduction")		local reductionValue = 0		if isDamageReduction then			reductionValue = math.floor(dp * (statusValue / 100.0))			print("monster damage reduction, value..+++++++++++++++++++++"..reductionValue)		end				--玩家是否有吸血光环判定		local isMaskOfDeath, deathValue = isExistModifyAttribute(ModelPlayer.getPlayerNode(), "mask_of_eath")		local increaseValue = 0		if isMaskOfDeath then			increaseValue = math.floor(dp * (deathValue / 100.0))			print("monster increase blood when attack.."..increaseValue)		end		dp = dp - reductionValue		return dp, increaseValue, DamageType		--	else		return dp, 0, DamageType	endend-- 玩家掉血计算function playerDropBlood(sprite, monsterDetailArr)	--伤害类型	local DamageType = AtkTypeJudge(monsterDetailArr.hit_ratio, monsterDetailArr.critical_ratio, mPlayerAttribute.miss_ratio, mPlayerAttribute.tenacity)	local dp = attackDamageCalculation(DamageType, monsterDetailArr.atk)	print("玩家掉血：",dp)		--玩家是否伤害减免判定	local isDamageReduction, statusValue = isExistModifyAttribute(ModelPlayer.getPlayerNode(), "damage_reduction")	local reductionValue = 0	if isDamageReduction then		reductionValue = math.floor(dp * (statusValue / 100.0))		print("player damage reduction, value..+++++++++++++++++++++++"..reductionValue)	end		--攻击玩家的怪物是否有吸血光环判定	local isMaskOfDeath, deathValue = isExistModifyAttribute(sprite, "mask_of_eath")	local increaseValue = 0	if isMaskOfDeath then		increaseValue = math.floor(dp * (deathValue / 100.0))		print("monster increase blood when attack.."..increaseValue)	end	dp = dp - reductionValue	return dp, increaseValueend-------------------------------------------effect++++++++++++++++++++++++++++++++--显示掉血特效function playLifeChangeEffect(pos, value)	if value == 0 then		return	end	local deltaH = 3 * CELLSIZE_HEIGHT/4	local newPos = ccp(pos.x,pos.y + deltaH)	local dpTpye	if value > 0 then		dpTpye = "add"	else		dpTpye = "reduce"		value = -value	end	g_sceneRoot:addChild(monsterDotShow(value, newPos, dpTpye, "hit"), g_Const_GameLayer.sceneChildLayer.show)end--怪物死亡后特效function playMonsterDieEffect()	local effect = createAnimation_signal("monster_death_%02d.png",8,0.1)		--播放破坏箱子特效	effect:setPosition(mTmxmapbg:convertToWorldSpace(ccp( getRealSpritePosByGridId(layerid) )));	effect:setAnchorPoint(ccp(0.25,0.25))	g_sceneRoot:addChild(effect,g_Const_GameLayer.sceneChildLayer.effect);end-------------------------------------------lewis skill++++++++++++++++++++++++++++++++++--------------------------------------------monster++++++++++++++++++++++++++++++++++++++++++++--通过怪物的精灵查找怪物属性function getMonsterInfoBySprite(sprite)	for key, element in pairs(mMonsterTable) do		if(element.sprite == sprite) then			return element		end	end	return nilend--通过怪物的地图坐标查找怪物信息function getMonsterInfoByLayerID(layerid)	for key, element in pairs(mMonsterTable) do		if(element.layerid == layerid) then			return element		end	end	return nilend--恢复怪物基本属性function restoreMonsterArr(monsterElement)	monsterElement.detailArr.atk 			= monsterElement.restoreArr.atk	monsterElement.detailArr.speed 			= monsterElement.restoreArr.speed	monsterElement.detailArr.hit_ratio		= monsterElement.restoreArr.hit_ratio	monsterElement.detailArr.critical_ratio = monsterElement.restoreArr.critical_ratio	monsterElement.detailArr.miss_ratio 	= monsterElement.restoreArr.miss_ratio	monsterElement.detailArr.tenacity 		= monsterElement.restoreArr.tenacityend--修改怪物属性function modifiedMonsterArr(monsterElement, modifyAttribute, modifyValue)	if "life" == modifyAttribute then		monsterElement.detailArr.life = monsterElement.detailArr.life + modifyValue		if monsterElement.detailArr.life < 0 then			monsterElement.detailArr.life = 0		elseif monsterElement.detailArr.life > monsterElement.restoreArr.life then			monsterElement.detailArr.life = monsterElement.restoreArr.life		end	elseif "atk" == modifyAttribute then		monsterElement.detailArr.atk = monsterElement.detailArr.atk + modifyValue	 	elseif "speed" == modifyAttribute then		monsterElement.detailArr.speed = monsterElement.detailArr.speed + modifyValue			 	elseif "hit_ratio" == modifyAttribute then		monsterElement.detailArr.hit_ratio = monsterElement.detailArr.hit_ratio + modifyValue			elseif "critical_ratio" == modifyAttribute then		monsterElement.detailArr.critical_ratio = monsterElement.detailArr.critical_ratio + modifyValue			elseif "miss_ratio" == modifyAttribute then		monsterElement.detailArr.miss_ratio = monsterElement.detailArr.miss_ratio + modifyValue			elseif "tenacity" == modifyAttribute then		monsterElement.detailArr.tenacity = monsterElement.detailArr.tenacity + modifyValue	endend--恢复玩家基本属性function restorePlayerArr()	local playerArr = ModelPlayer.getPlayerAllAttr()	local life = -1	if mPlayerAttribute.life ~= nil then		life = mPlayerAttribute.life	end		for key, val in pairs (playerArr) do		mPlayerAttribute[key] = val		--print("player attribute key "..key.." value "..mPlayerAttribute[key])	end		if life ~= -1 then		mPlayerAttribute.life = life	end		--mPlayerAttribute.atk = 10end--修改玩家属性function modifiedPlayerArr(modifyAttribute, modifyValue)	if "life" == modifyAttribute then		mPlayerAttribute.life = mPlayerAttribute.life + modifyValue		if mPlayerAttribute.life < 0 then			mPlayerAttribute.life = 0		end	elseif "atk" == modifyAttribute then		mPlayerAttribute.atk = mPlayerAttribute.atk + modifyValue	 	elseif "speed" == modifyAttribute then		mPlayerAttribute.speed = mPlayerAttribute.speed + modifyValue			 	elseif "hit_ratio" == modifyAttribute then		mPlayerAttribute.hit_ratio = mPlayerAttribute.hit_ratio + modifyValue			elseif "critical_ratio" == modifyAttribute then		mPlayerAttribute.critical_ratio = mPlayerAttribute.critical_ratio + modifyValue			elseif "miss_ratio" == modifyAttribute then		mPlayerAttribute.miss_ratio = mPlayerAttribute.miss_ratio + modifyValue			elseif "tenacity" == modifyAttribute then		mPlayerAttribute.tenacity = mPlayerAttribute.tenacity + modifyValue	endend-------------------------------------------------------------------光环效果功能++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--开始光环效果function startHalo(sprite, nameStr, valueStr)	local isForPlayer = false	if sprite == ModelPlayer:getPlayerNode() then		isForPlayer = true	end	local buffTable = {}	GameSkillMgr.parseStatusString(buffTable, nameStr, valueStr)	if #buffTable == 0 then		print("parse halo string error!!!")		return	end		for key, value in ipairs(buffTable) do		addHaloField(isForPlayer, sprite, value.modifyAttribute, value.modifyValue)	end	haloStep()	refreshAllArrView()end--增加光环作用字段function addHaloField(isForPlayer, haloID, haloName, haloValue)	print("addHaloField ".." "..haloName.." "..haloValue)	for key, element in pairs(mHaloTable) do		if element.haloID == haloID and element.name == haloName and element.isForPlayer == isForPlayer then			element.value = haloValue			print("i return++++++++++++++++++++++++++++++++++++++++++++++++++++++")			return		end	end		local haloUnit = {}	haloUnit.isForPlayer = isForPlayer	haloUnit.haloID = haloID	haloUnit.name = haloName	haloUnit.value = haloValue	table.insert(mHaloTable, haloUnit)end--移除光环效果function removeHalo(haloID)	local removeTable = {}	for key, value in pairs(mHaloTable) do		if value.haloID == haloID then			removeTable[key] = key		end	end		for key, value in pairs(removeTable) do		table.remove(mHaloTable, key)	endend--光环效果功能function haloStep()	local haloField = {"atk", "speed", "hit_ratio", "critical_ratio", "miss_ratio", "tenacity"}		--玩家光环数值加层计算	for key, value in pairs(haloField) do		local isExist, haloValue, haloElement = isExistHaloByName(true, value)		if isExist then			if mPlayerAttribute.haloStepCount > 0 then				modifiedPlayerArr(value, haloValue)				mPlayerAttribute.haloStepCount = mPlayerAttribute.haloStepCount + 1			end		end	end		if mPlayerAttribute.haloStepCount > 1 then		mPlayerAttribute.haloStepCount = 0	end		--怪物光环数值加层计算	for key, value in pairs(haloField) do		local isExist, haloValue, haloElement = isExistHaloByName(false, value)		if isExist then			for monsterKey, monsterElement in pairs(mMonsterTable) do				if monsterElement.haloStepCount > 0 then					modifiedMonsterArr(monsterElement, value, haloValue)					monsterElement.haloStepCount = monsterElement.haloStepCount + 1				end			end		end	end			for monsterKey, monsterElement in pairs(mMonsterTable) do		if monsterElement.haloStepCount > 1 then			monsterElement.haloStepCount = 0		end	end end--是否存在此光环效果function isExistHaloByName(isForPlayer, haloName)	local haloValue = 0	local haloElement = nil	for key, element in pairs(mHaloTable) do		if element.name == haloName and isForPlayer == element.isForPlayer then			--[[			--光环效果不叠加,取最大值			if element.value > haloValue then				haloValue = element.value				haloElement = element			end			]]--			haloValue = haloValue + element.value		end	end	if haloValue ~= 0 then		return true, haloValue, haloElement	end	return false, 0, nilend-------------------------------------------------------------------光环效果功能++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------------------------------------------------------buff locgic start+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--通过怪物的精灵查找怪物属性function getBuffInfoBySprite(sprite)	for key, element in pairs(mBuffInfoTable) do		if(element.sprite == sprite) then			return element		end	end	return nilend--开启buff状态function startBuffWithTarget(sprite, newBuffID, buffType, duration, newShaderName, nameStr, valueStr, target)	--开始光环效果	if duration <= 0 then		startHalo(sprite, nameStr, valueStr)		return	end	--字符串解析	local buffInfoUnit = getBuffInfoBySprite(sprite)	--是否	if buffInfoUnit == nil then		local newBuffInfoUnit = {}		newBuffInfoUnit.sprite = sprite		newBuffInfoUnit.shaderName = newShaderName		newBuffInfoUnit.target = target		newBuffInfoUnit.buffID = 0		newBuffInfoUnit.buffStepCount = 0		newBuffInfoUnit.buffDuration = 0		newBuffInfoUnit.buffModifyTable = {}					newBuffInfoUnit.debuffID = 0		newBuffInfoUnit.debuffStepCount = 0		newBuffInfoUnit.debuffDuration = 0		newBuffInfoUnit.debuffModifyTable = {}				if buffType == 1 then			newBuffInfoUnit.buffID = newBuffID			newBuffInfoUnit.buffStepCount = 0			newBuffInfoUnit.buffDuration = duration		else			newBuffInfoUnit.debuffID = newBuffID			newBuffInfoUnit.debuffStepCount = 0			newBuffInfoUnit.debuffDuration = duration		end			table.insert(mBuffInfoTable, newBuffInfoUnit)		buffInfoUnit = getBuffInfoBySprite(sprite)	else		buffInfoUnit.shaderName = newShaderName		buffInfoUnit.target = target		if buffType == 1 then			buffInfoUnit.buffID = newBuffID			buffInfoUnit.buffStepCount = 0			buffInfoUnit.buffDuration = duration			buffInfoUnit.buffModifyTable = {}		else			buffInfoUnit.debuffID = newBuffID			buffInfoUnit.debuffStepCount = 0			buffInfoUnit.debuffDuration = duration			buffInfoUnit.debuffModifyTable = {}		end	end		local modifyTable = nil	if buffType == 1 then		modifyTable = buffInfoUnit.buffModifyTable	else		modifyTable = buffInfoUnit.debuffModifyTable	end		GameSkillMgr.parseStatusString(modifyTable, nameStr, valueStr)	if #modifyTable == 0 then		print("parse buff string error!!!")		return	end		if newShaderName ~= nil then		--print("shader name "..newShaderName)		Lewis:spriteShaderEffect(sprite, newShaderName, true)	end		startHex(sprite)	print("buffTableCount.."..#buffInfoUnit.buffModifyTable.." debuffTableCount"..#buffInfoUnit.debuffModifyTable)end--每回合处理buff的逻辑引用计数+++function buffStep()	for buffKey, buffElement in pairs(mBuffInfoTable) do		buffElement.buffStepCount = buffElement.buffStepCount + 1		buffElement.debuffStepCount = buffElement.debuffStepCount + 1		local stepCount = 0		if buffElement.buffStepCount > buffElement.buffDuration then			buffElement.buffModifyTable = {}			stepCount = stepCount + 1			--print("buff End")		end				if buffElement.debuffStepCount > buffElement.debuffDuration then			buffElement.debuffModifyTable = {}			stepCount = stepCount + 1			--print("debuff end")		end				if stepCount >= 2 then			Lewis:spriteShaderEffect(buffElement.sprite, "none", false)		end	endend--怪物被debuff伤害,显示受伤动画function monsterModifiedLifeByBuff(sprite, modifyAttribute, modifyValue)	if modifyAttribute ~= "life" then return end	local monsterElement = getMonsterInfoBySprite(sprite)	if monsterElement == nil then		print("monsterHurtByDebuff..no node")		return	end	if modifyValue < 0 then		--怪物掉血		local function CFMonsterEffectByBuff(sender)			ModelMonster.updateDate(monsterElement.detailArr, monsterElement.restoreArr)			playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(monsterElement.sprite:getPosition())), modifyValue)			local life = monsterElement.detailArr.life + 0			if life <= 0 then --怪物死亡				monsterDead(monsterElement.layerid, sender)			else				switchActionToWait(sender, monsterElement.icon)			end			buffStepEnd()		end		mMonsterAutoStepCount = mMonsterAutoStepCount + 1		switchActionToHited(sprite, monsterElement.icon, CFMonsterEffectByBuff)	else		ModelMonster.updateDate(monsterElement.detailArr, monsterElement.restoreArr)		playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(monsterElement.sprite:getPosition())), modifyValue)	endend--玩家被debuff伤害,显示受伤动画function playerModifiedLifeByBuff(modifyAttribute, modifyValue)	if modifyAttribute ~= "life" then return end	if modifyValue < 0 then		--玩家掉血		local function CFPlayerHurtByBuff(sender)			if gameOverJudge() then				return			end			ModelPlayer.waitRender(mPlayerAttribute.icon)			buffStepEnd()		end		ModelPlayer.hitedRender(mPlayerAttribute.icon, CFPlayerHurtByBuff)		mMonsterAutoStepCount = mMonsterAutoStepCount + 1		playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(ModelPlayer:getPlayerNode():getPosition())), modifyValue)	else		--ModelMonster.updateDate(monsterElement.detailArr)		playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(ModelPlayer:getPlayerNode():getPosition())), modifyValue)	endend--启用buff修改目标的属性,一般用于一回合结束后function buffModifedTargetAttribute()	--print("test+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++sign..mBuffInfoTable count >>"..#mBuffInfoTable)	for buffKey, buffElement in pairs(mBuffInfoTable) do		--buff状态修改目标的属性		for modifyKey, modifyElement in ipairs(buffElement.buffModifyTable) do			if buffElement.target == "player" then				modifiedPlayerArr(modifyElement.modifyAttribute, modifyElement.modifyValue)				playerModifiedLifeByBuff(modifyElement.modifyAttribute, modifyElement.modifyValue)			else				modifiedMonsterArr(getMonsterInfoBySprite(buffElement.sprite), modifyElement.modifyAttribute, modifyElement.modifyValue)				monsterModifiedLifeByBuff(buffElement.sprite, modifyElement.modifyAttribute, modifyElement.modifyValue)			end			--print("buff modifyAttribute "..modifyElement.modifyAttribute.." modifyValue "..modifyElement.modifyValue)		end				--debuff状态修改目标属性		for modifyKey, modifyElement in ipairs(buffElement.debuffModifyTable) do			if buffElement.target == "player" then				modifiedPlayerArr(modifyElement.modifyAttribute, modifyElement.modifyValue)				playerModifiedLifeByBuff(modifyElement.modifyAttribute, modifyElement.modifyValue)			else				modifiedMonsterArr(getMonsterInfoBySprite(buffElement.sprite), modifyElement.modifyAttribute, modifyElement.modifyValue)				monsterModifiedLifeByBuff(buffElement.sprite, modifyElement.modifyAttribute, modifyElement.modifyValue)			end			--print("debuff modifyAttribute "..modifyElement.modifyAttribute.."modifyValue "..modifyElement.modifyValue)		end	endend--是否有该状态字段判定,有则返回对应值function isExistModifyAttribute(sprite, modifyAttribute)	local buffElement = getBuffInfoBySprite(sprite)	if buffElement == nil then		return false, 0	end		for modifyKey, modifyElement in pairs(buffElement.buffModifyTable) do		if modifyElement.modifyAttribute == modifyAttribute then			--print("find modifyAttribute in buff table........."..modifyAttribute.."buffElement.buffModifyTable count "..#buffElement.buffModifyTable)			return true, modifyElement.modifyValue		end	end		for modifyKey, modifyElement in pairs(buffElement.debuffModifyTable) do		if modifyElement.modifyAttribute == modifyAttribute then			--print("find modifyAttribute in debuff table........."..modifyAttribute.."buffElement.buffModifyTable count "..#buffElement.debuffModifyTable)			return true, modifyElement.modifyValue		end	end	return false, 0end--开始妖术,使角色变型function startHex(sprite)	local isExistHex, hexValue = isExistModifyAttribute(sprite, "hex")	if isExistHex then		if sprite == ModelPlayer:getPlayerNode() then			mPlayerAttribute.icon = hexValue			ModelPlayer.waitRender(mPlayerAttribute.icon)			return		end				local monsterElement = getMonsterInfoBySprite(sprite)		if monsterElement == nil then			return		end		monsterElement.icon = hexValue		switchActionToWait(monsterElement.sprite, monsterElement.icon)	endend--判定是否使角色正常function hexStep()	for key, monsterElement in pairs(mMonsterTable) do		local isExistHex, hexValue = isExistModifyAttribute(monsterElement.sprite, "hex")		if isExistHex then			monsterElement.icon = hexValue		else			monsterElement.icon = monsterElement.restoreArr.icon		end		switchActionToWait(monsterElement.sprite, monsterElement.icon)	end		local isExistHex, hexValue = isExistModifyAttribute(ModelPlayer:getPlayerNode(), "hex")	if isExistHex then		mPlayerAttribute.icon = hexValue	else		mPlayerAttribute.icon = mPlayerAttribute.restoreIcon	end	ModelPlayer.waitRender(mPlayerAttribute.icon)	print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")end-------------------------------------------------------------------buff locgic end+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------------------------------------------------------fight logic start+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------------------------------------------------怪物普通攻击+++++++++++++++++++++++++++++++++++++++++++++++++function monsterNormalAttack(monsterSprite, remark)	mIsPlayAnimation = true	local monsterElement = getMonsterInfoBySprite(monsterSprite)	if monsterElement == nil then		nextStep("monsterNormalAttack", monsterSprite, remark)		return	end		--怪物是否被缴械判定	local isDisarm, statusValue = isExistModifyAttribute(monsterSprite, "disarm")	if isDisarm then--被缴械,跳过攻击回合		print("skip monster attack step")		nextStep("monsterNormalAttack", monsterSprite, remark)		return	end		--怪物是否不可操作判定	isDisarm, statusValue = isExistModifyAttribute(monsterSprite, "uncontrollable")	if isDisarm then--被缴械,跳过攻击回合		print("skip monster attack step")		nextStep("monsterNormalAttack", monsterSprite, remark)		return	end		--怪物攻击动画结束,对玩家伤害数值计算	local function CFMonsterNormalAttack(sender)		-- 玩家被攻击后的回调		local function CFPlayerHurt(sender)			if gameOverJudge() then				return			end			ModelPlayer.waitRender(mPlayerAttribute.icon)			if remark ~= "monsterInitiativeAttack" then				monsterElement.stepCount = -1			end			--检测是否多重施法			local isMulticast, multicastValue = isExistModifyAttribute(monsterSprite, "multicast")			if isMulticast then				monsterUseSkill(monsterSprite, multicastValue, remark)			else				nextStep("monsterNormalAttack", monsterSprite, remark)			end		end		ModelPlayer.hitedRender(mPlayerAttribute.icon, CFPlayerHurt)		local dp, increaseBlood = playerDropBlood(monsterElement.sprite, monsterElement.detailArr)		print("increaseBlood value.."..increaseBlood)		--吸血光环效果		if increaseBlood > 0 then			modifiedMonsterArr(monsterElement, "life", increaseBlood)			ModelMonster.updateDate(monsterElement.detailArr, monsterElement.restoreArr)			playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(monsterElement.sprite:getPosition())), increaseBlood)		end		playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(ModelPlayer:getPlayerNode():getPosition())), -dp)		modifiedPlayerArr("life", -dp)		ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)			end		--有飞行轨迹	local flyEffectID = monsterElement.detailArr.fly_effect_id or 0	local frontEffectID = monsterElement.detailArr.front_effect_id or 0	local backEffectID = monsterElement.detailArr.back_effect_id or 0		--flyEffectID = 21	--frontEffectID = 3		--弹道飞行结束	local function ballisticDone()		CFMonsterNormalAttack(monsterSprite)	end		--怪物抬手动作完毕	local function CFMonsterHandsUp(sender)		local sx, sy = monsterSprite:getPosition()		local dx, dy = ModelPlayer:getPlayerNode():getPosition()		GameSkillEffectLayer.flightTrajectory(ballisticDone, flyEffectID, frontEffectID, backEffectID, ccp(sx, sy), ccp(dx, dy))	end		--怪物收手动作	local function CFMonsterHandsBack(sender)		switchActionToWait(sender, monsterElement.icon)	end	--怪物普攻动作播放完毕	local function CFMonsterNormalAttackAminateDone(sender)		switchActionToWait(sender, monsterElement.icon)		CFMonsterNormalAttack(monsterSprite)	end		if flyEffectID == 0 and frontEffectID == 0 then		switchActionToAttack(monsterElement.sprite, monsterElement.icon, CFMonsterNormalAttackAminateDone)	else		switchActionToUseSkill(monsterElement.sprite, monsterElement.icon, 3, CFMonsterHandsUp, CFMonsterHandsBack)	endend----------------------------------------------------怪物使用技能++++++++++++++++++++++++++++++++++++++++++++++function monsterUseSkill(monsterSprite, skillID, remark)	mIsPlayAnimation = true	local effectCount = 0	local monsterElement = getMonsterInfoBySprite(monsterSprite)	if monsterElement == nil then		nextStep("monsterUseSkill", monsterSprite, remark)		return	end		--跳转到下一回合判定	local function skipToNextStep()		if effectCount <= 0 then			nextStep("monsterUseSkill", monsterSprite, remark)		end	end		--怪物技能动画施放完毕	local function CFMonsterSkillEffectDone(sprite, shaderName, base_damage, bonus_damage, userData)		effectCount = effectCount - 1		if shaderName ~= nil then			Lewis:spriteShaderEffect(sprite, shaderName, true)		end				--print("monsterUseSkill...add value.."..damageValue.." caster "..userData.caster.." target.."..userData.target)		local damageValue = math.floor((base_damage / 100.0) * monsterElement.detailArr.atk + bonus_damage)		local value = damageValue		--userData.caster 技能施放者一定是怪物		if userData.target == "player" then --目标是玩家，对玩家进行伤害			local function CFPlayerHurtBySkill(sender)				if gameOverJudge() then					return				end				ModelPlayer.waitRender(mPlayerAttribute.icon)				skipToNextStep()			end			ModelPlayer.hitedRender(mPlayerAttribute.icon, CFPlayerHurtBySkill)			playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(sprite:getPosition())), -value)			modifiedPlayerArr("life", -value)			ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)		else			value = damageValue			modifiedMonsterArr(monsterElement, "life", value)			ModelMonster.updateDate(monsterElement.detailArr, monsterElement.restoreArr)			playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(sprite:getPosition())), value)			skipToNextStep()		end	end		--怪物施法前摇完毕	local function CFMonsterSkillEffectFrame_New(sender)		local userData = {}		userData.isPlayer = false		userData.skilEffectDoneCB = CFMonsterSkillEffectDone		GameSkillMgr.makeUserData("monster", skillID, sender, ModelPlayer.getPlayerNode(), userData)		GameSkillMgr.startWithUseSkillForPlayer(skillID, userData)	end	--怪物施法动作播放完毕	local function CFMonsterSkillActionDone_New(sender)		switchActionToWait(sender, monsterElement.icon)	end	switchActionToUseSkill(monsterElement.sprite, monsterElement.icon, 3, CFMonsterSkillEffectFrame_New, CFMonsterSkillActionDone_New)end-------------------------------------物品对玩家使用技能,如血瓶,陷阱+++++++++++++++++++++++++++++++++++++++++++++++++function propUseSkill(propName, skillID, remark)	mIsPlayAnimation = true	local function CFPropSkillEffectDone(sprite, shaderName, base_damage, bonus_damage, userData)		modifiedPlayerArr("life", bonus_damage)		ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)		playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(ModelPlayer:getPlayerNode():getPosition())), bonus_damage)		if bonus_damage < 0 then			local function CFPlayerHurtByPropSkill(sender)				if gameOverJudge() then					return				end				ModelPlayer.waitRender(mPlayerAttribute.icon)				nextStep("propUseSkill", nil, remark)			end			ModelPlayer.hitedRender(mPlayerAttribute.icon, CFPlayerHurtByPropSkill)		else			nextStep("propUseSkill", nil, remark)		end	end	local userData = {}	userData.isPlayer = false	userData.skilEffectDoneCB = CFPropSkillEffectDone	GameSkillMgr.makeUserData("prop", skillID, nil, ModelPlayer.getPlayerNode(), userData)	GameSkillMgr.startWithUseSkillForPlayer(skillID, userData)end----------------------------------------------玩家普通攻击+++++++++++++++++++++++++++++++++++++++++++++++++function playerNormalAttack(targetMonsterSprite, remark)	mIsPlayAnimation = true	--玩家对怪物伤害逻辑计算	local function CFPlayerNormalAttack(sender)		local monsterElement = getMonsterInfoBySprite(targetMonsterSprite)		if monsterElement == nil then			nextStep("playerNormalAttack", targetMonsterSprite, "nextRound")			return		end		local dp, increaseBlood, DamageType = monsterDropBlood(monsterElement.sprite, monsterElement.detailArr)		if DamageType == "miss" then			--怪物躲闪回调			local function CFMonsterDodge(node)				switchActionToWait(monsterElement.sprite, monsterElement.icon)				nextStep("playerNormalAttack", targetMonsterSprite, remark)			end			Anction_Miss(monsterElement.sprite, CFMonsterDodge)		else			--怪物受伤害数值计算			modifiedMonsterArr(monsterElement, "life", -dp)			ModelMonster.updateDate(monsterElement.detailArr, monsterElement.restoreArr)			playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(monsterElement.sprite:getPosition())), -dp)						--玩家是否有吸血光环效果			print("player increaseBlood value.."..increaseBlood)			if increaseBlood > 0 then				modifiedPlayerArr("life", increaseBlood)				ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)				playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(ModelPlayer:getPlayerNode():getPosition())), increaseBlood)			end						--怪物伤害动画播放完毕			local function CFMonsterHurt(sender)				local life = monsterElement.detailArr.life + 0				if life <= 0 then --怪物死亡					monsterDead(monsterElement.layerid, sender)					nextStep("playerNormalAttack", targetMonsterSprite, "nextRound")				else					monsterElement.autoPlayCount = -1					switchActionToWait(monsterElement.sprite, monsterElement.icon)					--检测是否多重施法					local isMulticast, multicastValue = isExistModifyAttribute(ModelPlayer:getPlayerNode(), "multicast")					if isMulticast then						monsterElement.isLockOn = true						print("player Multicast ++++++++++++++++++++++++++++++++++++")						playerUseSkill(multicastValue, remark)					else						nextStep("playerNormalAttack", targetMonsterSprite, remark)					end				end			end			switchActionToHited(monsterElement.sprite, monsterElement.icon, CFMonsterHurt)		end	end	--有飞行轨迹	local flyEffectID = mPlayerAttribute.fly_effect_id or 0	local frontEffectID = mPlayerAttribute.front_effect_id or 0	local backEffectID = mPlayerAttribute.back_effect_id or 0	--flyEffectID = 3	--frontEffectID = 0		--弹道飞行结束	local function ballisticDone()		CFPlayerNormalAttack(ModelPlayer:getPlayerNode())	end		--玩家抬手动作完毕	local function CFPlayerHandsUp(sender)		local sx, sy = ModelPlayer:getPlayerNode():getPosition()		local dx, dy = targetMonsterSprite:getPosition()		GameSkillEffectLayer.flightTrajectory(ballisticDone, flyEffectID, frontEffectID, backEffectID, ccp(sx, sy), ccp(dx, dy))	end		--玩家收手动作	local function CFPlayerHandsBack(sender)		ModelPlayer.waitRender(mPlayerAttribute.icon)	end	--玩家普攻动作播放完毕	local function CFPlayerNormalAttackAminateDone(sender)		ModelPlayer.waitRender(mPlayerAttribute.icon)		CFPlayerNormalAttack(ModelPlayer:getPlayerNode())	end			if flyEffectID == 0 and frontEffectID == 0 then		ModelPlayer.atkRender(mPlayerAttribute.icon, CFPlayerNormalAttackAminateDone)	else		ModelPlayer.skillAtkRender(mPlayerAttribute.icon, 4, CFPlayerHandsUp, CFPlayerHandsBack)	end	end----------------------------------------------------玩家使用技能++++++++++++++++++++++++++++++++++++++++++++++function playerUseSkill(skillID, remark)	--print("function player use skill+++++++++++++++++++++++++++++++++++++++++++++++++++++++++")	mIsPlayAnimation = true	local effectCount = 0	--跳转到下一回合判定	local function skipToNextStep(monsterSprite)		if effectCount <= 0 then			nextStep("playerUseSkill", monsterSprite, remark)		end	end		--技能动画施放完毕	local function CFPlayerSkillEffectDone(sprite, shaderName, base_damage, bonus_damage, userData)		effectCount = effectCount - 1		if shaderName ~= nil then			Lewis:spriteShaderEffect(sprite, shaderName, true)		end		--print("playerUseSkill...add value.."..damageValue.." caster "..userData.caster.." target.."..userData.target)		local damageValue = math.floor((base_damage / 100.0) * mPlayerAttribute.atk + bonus_damage)		local value = damageValue		--userData.caster 技能施放者一定是玩家		if userData.target == "player" then			value = -damageValue			playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(sprite:getPosition())), -value)			skipToNextStep(sprite)		else			local monsterElement = getMonsterInfoBySprite(sprite)			if monsterElement == nil then				return			end			value = -damageValue			modifiedMonsterArr(monsterElement, "life", value)			playLifeChangeEffect(g_sceneRoot:convertToWorldSpace(ccp(sprite:getPosition())), value)						--怪物被技伤害后回调			local function CFMonsterHurtBySkill(sender)				ModelMonster.updateDate(monsterElement.detailArr, monsterElement.restoreArr) 				local life = monsterElement.detailArr.life + 0				if life <= 0 then --怪物死亡					monsterDead(monsterElement.layerid, sender)				else					switchActionToWait(sender, monsterElement.icon)				end				skipToNextStep(sprite)			end			switchActionToHited(sprite, monsterElement.icon, CFMonsterHurtBySkill)			end	end		--玩家施法前摇完毕	local function CFPlayerSkillEffectFrame_New(sender)		--print("player use skill effect frame done")		local target = GameSkillMgr.playerMagicTargetJudge(skillID)		if target == "monster" then			for key, element in ipairs(mMonsterTable) do				if element.isLockOn == true then					effectCount = effectCount + 1					element.isLockOn = false								local userData = {}					userData.isPlayer = true					userData.skilEffectDoneCB = CFPlayerSkillEffectDone					GameSkillMgr.makeUserData("player", skillID, element.sprite, ModelPlayer.getPlayerNode(), userData)					GameSkillMgr.startWithSingleTarget(skillID, userData)				end			end		else			effectCount = 1			local userData = {}			userData.isPlayer = true			userData.skilEffectDoneCB = CFPlayerSkillEffectDone			GameSkillMgr.makeUserData("player", skillID, nil, ModelPlayer.getPlayerNode(), userData)			GameSkillMgr.startWithSingleTarget(skillID, userData)		end	end		--玩家使用技能动画播放完毕	local function CFPlayerSkillActionDone_New(sender)		--print("player use skill animate done")		ModelPlayer.waitRender(mPlayerAttribute.icon)	end	ModelPlayer.skillAtkRender(mPlayerAttribute.icon, 4, CFPlayerSkillEffectFrame_New, CFPlayerSkillActionDone_New)end-----------------------------------------------------------function nextStep(preStepName, monsterSprite, remark)	if mIsGameOver then		return	end	print("next step+++++++++++++++++"..preStepName.."remark.."..remark)	mIsPlayAnimation = false	if remark == "nextRound" then		FightDateCache.Handle_mNextRound(Handle_NextRoundMapRender)	elseif remark == "playerFirst" then		monsterNormalAttack(monsterSprite, "nextRound")	elseif remark == "monsterFirst" then		playerNormalAttack(monsterSprite, "nextRound")	elseif remark == "monsterUseSkill" then		monsterAutoPlay()	elseif remark == "monsterInitiativeAttack" then		monsterAutoPlay()	end	--FightDateCache.Handle_mNextRound(Handle_NextRoundMapRender)end-------------------------------------------------------------------fight logic end+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++function monsterDead(layerid, sender)	local effect = createAnimation_signal("monster_death_%02d.png",8,0.1)			effect:setPosition(getTmxMapBackground():convertToWorldSpace(ccp( getRealSpritePosByGridId(layerid) )));	effect:setAnchorPoint(ccp(0.25,0.25))	g_sceneRoot:addChild(effect,g_Const_GameLayer.sceneChildLayer.effect)	m_GildEvent[layerid].staus = g_Const_Sprite.Type.background  -- 怪物死亡		--CloseXLimit(target - mSpriteMask)	if m_GildEvent[layerid].otherDate.attack_type == 1 then 		print("主动怪死亡 开遮罩")		OpenMask(layerid,true)	else        CloseXLimit(layerid)	end	sender:getParent():removeChild(sender,true)	g_sceneRoot:removeChildByTag(layerid + mSpriteUIMask,true)	g_sceneRoot:removeChildByTag(layerid + mSpriteAktFontMask,true)	g_sceneRoot:removeChildByTag(layerid + mSpriteLifeFontMask,true)	g_sceneRoot:removeChildByTag(layerid + mSpriteProgressMask,true)	local monster = getMonsterInfoByLayerID(layerid)	FightDateCache.KillMonster(monster.otherDate.id)		for key, element in ipairs(mMonsterTable) do		if element.sprite == sender then			--竞技场怪物死亡			if element.level == "player" then				FightDateCache.HandleGameSettle(1)--竞技场胜利				mIsGameOver = true			else				removeHalo(element.sprite)				table.remove(mMonsterTable, key)			end			break		end	end			for buffKey, buffElement in pairs(mBuffInfoTable) do		if buffElement.sprite == sender then			table.remove(mBuffInfoTable, buffKey)		end	end			--死亡创建道具	if m_GildEvent[layerid].otherDate.dropout ~= 0 and m_GildEvent[layerid].otherDate.dropout ~= nil  then		createItemInGameScene(layerid,m_GildEvent[layerid].otherDate.dropout,"box") --泛指掉宝箱	else 		createItemInGameScene(layerid,m_GildEvent[layerid].otherDate.dropout,nil)	end		end--玩家主动技能加调local function autoStartSkillStartListener(skillID, target)	--对所有怪物施法	if target == 4 then		local effectCount = 0		for key, element in ipairs(mMonsterTable) do			element.isLockOn = true			effectCount = effectCount + 1		end		if effectCount ~= 0 then			playerUseSkill(skillID, "playUseSkill")			print("start full screen skill monster count.."..effectCount)			return true		end	end		--对玩家自己施法	if target == 1 then		playerUseSkill(skillID, "playUseSkill")		print("skill to player")		return true	end		return falseend-- 对怪物点击的事件处理 local function HandleOnClickMonster(layerid,x1,y1, bIsMask)	local monsterElement = getMonsterInfoByLayerID(layerid)	if monsterElement == nil then		return	end	--是否使用技能	local isUseSkill, skillID, target = GameSkillMgr.isUseSingleMonsterTargetSkill()	if isUseSkill then		monsterElement.isLockOn = true		playerUseSkill(skillID, "playerUseSkill")		GameSkillMgr.startPlayerSkill()		return	end		if bIsMask then		return	end		local bIsPlayerFirtst = SenteJudge(monsterElement.detailArr)			--先手判断	if bIsPlayerFirtst then		playerNormalAttack(monsterElement.sprite, "playerFirst")	else		monsterNormalAttack(monsterElement.sprite, "monsterFirst")	endend--- 创建障碍local function createBarrierInGameSenen(layerid,x,y)	local spBarrier = FactoryGameSprite.createBarrierPos(nil)	--spBarrier:setPosition(ccp(x,y))	spBarrier:setPosition(getTmxMapBackground():convertToWorldSpace(ccp(x,y)));	g_sceneRoot:addChild(spBarrier,g_Const_GameLayer.sceneChildLayer.sprite+layerid);end--寻找 并 创建 关联怪function seekandCreateRelaMonster(layerid)	local ReLaList = m_GildEvent[layerid].otherDate.relative_id	if ReLaList== nil then		print("没有关联怪")		return	end	if type(ReLaList) ~= "table" then		print("关联数据类型有误")		return	end	print("准备翻开关联怪")	for pos,data in pairs(m_GildEvent) do		if data.hidden == g_Const_Sprite.Type.monster  		   and (data.staus == g_Const_Sprite.Type.gird or data.staus == g_Const_Sprite.Type.limit)then			--如果背后是怪 and (格子还没开 or 或者被X 的时候)			for key,monsterid in pairs(ReLaList) do				local id = tonumber(monsterid)				if id == data.otherDate.id then 					HandleOnClickGrid(pos,"RelaOpened")					createMonsterInGameSenen(pos,data.otherDate,3)				end			end					end	endend--- 创建怪物  layerid :(图层/地块ID)  x,y:( 坐标)  otherDate:(其他数据),CreateType 1: 创建主动攻击怪 2: 翻格子创建 3:被关联function createMonsterInGameSenen(layerid,otherDate,CreateType)	local monsterDetailArr = ModelMonster.getMonsterById(otherDate.id)	monsterDetailArr.pos = layerid	--create picture	local monster = FactoryGameSprite.createMonsterSprite(monsterDetailArr.icon) --转成num类型	monster:setTag(layerid+mSpriteMask)	local x,y = getRealSpritePosByGridId(layerid)	monster:setPosition(getTmxMapBackground():convertToWorldSpace(ccp(x + CELLSIZE_WIDTH/2,y)));		local monsterTableElement = {}	monsterTableElement.level = "monster"	monsterTableElement.sprite = monster	monsterTableElement.layerid = layerid	monsterTableElement.detailArr = monsterDetailArr	monsterTableElement.restoreArr = ModelMonster.getMonsterById(otherDate.id)	monsterTableElement.icon = monsterDetailArr.icon	monsterTableElement.otherDate = otherDate	monsterTableElement.isLockOn = false	monsterTableElement.autoPlayCount = 0	monsterTableElement.haloStepCount = 1	monsterTableElement.skillCDCount = 0		--判定配置表是否有误	local skillID = monsterDetailArr.skills	print("monster skill id from talbe..+++++++++++++++++++"..skillID)	if GameSkillMgr.isExsitSkillID(skillID) then		monsterDetailArr.skillCDProgress = 0.0		monsterTableElement.skillID = skillID	else		monsterDetailArr.skillCDProgress = nil		monsterTableElement.skillID = 0	end		--主动怪没技能	if monsterDetailArr.attack_type == 1 then		monsterDetailArr.skillCDProgress = nil		monsterTableElement.skillID = 0	end		--test	--monsterTableElement.skillID = 1	--monsterDetailArr.skillCDProgress = 0.0	table.insert(mMonsterTable, monsterTableElement)	print("monster table count: "..#mMonsterTable)	ModelMonster.initArrRender(monster, monsterDetailArr)	ModelMonster.updateDate(monsterDetailArr, monsterTableElement.restoreArr)	g_sceneRoot:addChild(monster,g_Const_GameLayer.sceneChildLayer.sprite+layerid);	m_GildEvent[layerid].staus = g_Const_Sprite.Type.monster	if CreateType ~= 1 then    --手动翻格子 创建		OpenXLimit(layerid,true)	end		if CreateType ~= 3 then 		seekandCreateRelaMonster(layerid)	end		--如果是被动技能直接播放	local cd = GameSkillMgr.getSkillCD(monsterTableElement.skillID)	if cd == 0 then		print("the skill id in monster: ++++++++++++++++++               	"..monsterTableElement.skillID)		monsterUseSkill(monsterTableElement.sprite, monsterTableElement.skillID, "nextRound")		return "RelaOpened"	end	return nilend--创建敌人（竞技场专属）function createEnemyInGameSenen(layerid,otherDate)	--create Rendernode	local emeny,emeny_icon = FactoryGameSprite.createEnemySprite(otherDate.type)	emeny:setTag(layerid+mSpriteMask)	local x,y = getRealSpritePosByGridId(layerid)	emeny:setPosition(getTmxMapBackground():convertToWorldSpace(ccp(x + CELLSIZE_WIDTH/2,y)));	g_sceneRoot:addChild(emeny,g_Const_GameLayer.sceneChildLayer.sprite+layerid);	m_GildEvent[layerid].staus = g_Const_Sprite.Type.monster	--create Date	local newMonsterAttr = {}	newMonsterAttr = ModelMonster.initEnemyAttr(otherDate.battle_prop)	newMonsterAttr.attack_type = 1  --敌人创建出来就是主动怪	newMonsterAttr.icon = emeny_icon	print("emeny_icon",emeny_icon)	print("emeny_icon",emeny_icon) print("emeny_icon",emeny_icon) print("emeny_icon",emeny_icon) print("emeny_icon",emeny_icon) print("emeny_icon",emeny_icon) print("emeny_icon",emeny_icon)	newMonsterAttr.pos = layerid		local restoreArr = {}	restoreArr = ModelMonster.initEnemyAttr(otherDate.battle_prop)	restoreArr.attack_type = 1  --敌人创建出来就是主动怪	restoreArr.icon = emeny_icon	restoreArr.pos = layerid	--newMonsterAttr.sculpture		--这个就是它的技能ID表  固定4个长度没有后台就发0	--clog("创建竞技场技能")	for key,value in pairs(newMonsterAttr.sculpture) do		print("KEY -->",key,"Value",value)	end	--TOOD:添加初始化技能代码		local monsterTableElement = {}	monsterTableElement.level = "player"	monsterTableElement.sprite = emeny	monsterTableElement.layerid = layerid	monsterTableElement.detailArr = newMonsterAttr	monsterTableElement.restoreArr = restoreArr	monsterTableElement.icon = newMonsterAttr.icon	monsterTableElement.otherDate = otherDate	monsterTableElement.isLockOn = false	monsterTableElement.autoPlayCount = 0	monsterTableElement.haloStepCount = 1	monsterTableElement.skillCDCount = 0	newMonsterAttr.skillCDProgress = nil	monsterTableElement.skillID = 0	table.insert(mMonsterTable, monsterTableElement)	ModelMonster.initArrRender(emeny, newMonsterAttr)end-- 创建怪物掉落的道具function createItemInGameScene(layerid,dropout_id,dropType) 	--待加入动画ing	FactoryGameSprite.createItem(layerid,dropout_id,dropType)	if dropType ~= nil then 		m_GildEvent[layerid].staus = g_Const_Sprite.Type.prop	endendfunction createInitativeMonster()	for k,v in pairs (m_GildEvent) do		if v.otherDate.attack_type == 1 then 			print("这是主动怪",k)					local sprite = getGridNodeRoot():getChildByTag(k)			sprite:setVisible(false)			--FightDateCache.ConductCheck(layerid,1,nil) --testCode			--OpenMask(layerid,true)			local effect = createAnimation_signal("shouchuang_%03d.png",8,0.1)		--播放破坏箱子特效			effect:setPosition(getTmxMapBackground():convertToWorldSpace(ccp( getRealSpritePosByGridId(k) )));			effect:setAnchorPoint(ccp(0.3,0.3));			g_sceneRoot:addChild(effect,g_Const_GameLayer.sceneChildLayer.effect);			createMonsterInGameSenen(k,v.otherDate,1)		end	endendfunction HandleFightTouchBegan(x,y)		touchBeginPoint = ccp(x,y)--FIXME 要考虑 转成 world坐标系？？？		if(mIsPlayAnimation) then	--动画禁事件			print("mIsPlayAnimation!!!!!!!!!!!!")			return 		end		if (UIManager.UILayerNumber() > 0 ) then 			--print("UIManager.UILayerNumber!!!!!!!!!!!!")			return		end		if(getTmxMapBackground():boundingBox():containsPoint(touchBeginPoint)) then			--点击事件处理(待封装)  测试代码			local tileCoord,layerid = getTouchPointInTileMap(touchBeginPoint,getTmxMapBackground());--遮罩层TMX地图的点 和图层			mCurClickMonsterPos = layerid			--local tmxlayer = getTmxMapBackground():layerNamed("layer1")			--tileCoord = ccp(getPosByGridID(layerid))			--local	sprite = tmxlayer:tileAt(tileCoord);			--x1,y1 = sprite:getPosition()   --- 获取当前格子的坐标			local x1,y1 = getRealSpritePosByGridId(layerid)							local curGildEvent = m_GildEvent[layerid]  --获取当前事件格子							if(	m_GildEvent[layerid].staus == g_Const_Sprite.Type.gird  and m_GildEvent[layerid].isMasked == false) then -- 点击为可以开启的格子				local openType = nil				if(curGildEvent.hidden == g_Const_SpriteId.goldCoin) then	--泛指道具					--HandleOnClickProp(layerid,x1,y1)				elseif(curGildEvent.hidden == g_Const_Sprite.Type.monster) then  --泛指怪物				   openType = createMonsterInGameSenen(layerid,curGildEvent.otherDate,2)				elseif(m_GildEvent[layerid].hidden == g_Const_SpriteId.null) then  --背后什么也没有 改成 else 					m_GildEvent[layerid].staus = g_Const_Sprite.Type.background				elseif(curGildEvent.hidden == g_Const_Sprite.Type.barrier) then					cclog("开始创建障碍图片")					createBarrierInGameSenen(layerid,x1,y1)					m_GildEvent[layerid].staus = g_Const_Sprite.Type.background				elseif(curGildEvent.hidden == g_Const_Sprite.Type.door) then					cclog("发现门")					FactoryGameSprite.createDoorInScene(layerid,x1,y1)					m_GildEvent[layerid].staus = g_Const_Sprite.Type.door				elseif(curGildEvent.hidden == g_Const_Sprite.Type.enemy) then	--竞技场敌人					cclog("遇见敌人---->竞技场专属")					createEnemyInGameSenen(layerid,curGildEvent.otherDate)				elseif(curGildEvent.hidden == g_Const_Sprite.Type.trap) then					print("发现陷阱 id->",curGildEvent.otherDate.id)					local changestatus, trap_date=  FigthEvent.Create(layerid,curGildEvent.otherDate.id)					m_GildEvent[layerid].staus = changestatus 					m_GildEvent[layerid].otherDate.trap_date = trap_date					-- 如果是陷阱 trap_date == 技能ID				end								HandleOnClickGrid(layerid, openType)			--点击是怪物			elseif (curGildEvent.staus == g_Const_Sprite.Type.monster) then					HandleOnClickMonster(layerid,x1,y1, m_GildEvent[layerid].isMasked)			--点击的是竞技场敌人			--elseif (curGildEvent.staus == g_Const_Sprite.Type.enemy) then					--cclog("点击竞技场敌人")					--Toast.show("竞技场功能尚未实现")					--HandleOnClickMonster(layerid,x1,y1, false)			-- 点击是金币			elseif (m_GildEvent[layerid].staus == g_Const_Sprite.Type.gold) then										FigthEvent.HandleOnClickGold(layerid, m_GildEvent[layerid].otherDate.trap_date)					m_GildEvent[layerid].staus = g_Const_Sprite.Type.background 			-- 点击是血瓶 			elseif (m_GildEvent[layerid].staus == g_Const_Sprite.Type.blood) then							FigthEvent.HandleOnClickBlood(layerid,m_GildEvent[layerid].otherDate.trap_date)					m_GildEvent[layerid].staus = g_Const_Sprite.Type.background 			-- 点击的是 （可拾取）道具			elseif (m_GildEvent[layerid].staus == g_Const_Sprite.Type.prop) then					--宝箱被移走 要在地面产生 一个骷髅					HandleOnClickProp(layerid,nil)					--FightDateCache.getItemInGameScene(curGildEvent.otherDate.dropout)					--local Itemnode = g_sceneRoot:getChildByTag(layerid+mSpriteMask)					--FightAnimation_moveItem(Itemnode)					--m_GildEvent[layerid].staus = g_Const_Sprite.Type.background  -- 拾取道具			elseif (m_GildEvent[layerid].staus == g_Const_Sprite.Type.door) then					g_CurLevelIndex = g_CurLevelIndex + 1					if( FightDateCache.getCurFuBenLength() >= g_CurLevelIndex) then						createGameSceneLayer(g_Const_GameStatus.GamePlay)	--重新加载地图						ModelPlayer.refreshPlayerArrViewInFightLayer(mPlayerAttribute)            					else						-- 1：表示正常过关						FightDateCache.HandleGameSettle(1)					end			end		endendfunction HandleFightTouchMoved(x,y)	--print(x,"___",y)endfunction HandleFightTouchEnded(x,y)	touchBeginPoint = nilendlocal function Handle_player_req_game_settle(tb)    if CopyDateCache.GameType == game_type["common"] then 		local fb = getCurFBDetail()		tb.gold = fb.gold		tb.exp = fb.exp		tb.name = fb.name		tb.Pickup_items = FightDateCache.getPickup_items()		UIManager.push("UI_FightOver",tb)		EventCenter_post("ED_PASS_LOCATION", FightDateCache.common().curFBid)				UIManager.BounceTop()	elseif CopyDateCache.GameType == game_type["push_tower"] then 		cclog("推塔---过关---结算",tb.result)		if tb.result == map_settle_result["map_settle_next_map"] then			tb.EventType = "nextLayer"		elseif tb.result == map_settle_result["map_settle_finish"] then			tb.EventType = "endLayer"		elseif tb.result == map_settle_result["map_settle_died"] then			tb.EventType = "endLayer"		end		UIManager.push("UI_TowerSettle",tb)	elseif  CopyDateCache.GameType == "jjc" then  			if tb.result == 1 then -- 挑战成功			UIManager.push("UI_JJCSuccess",tb)		elseif tb.result == 2 then --挑战失败			UIManager.push("UI_JJCFailed",tb)		end	end	    --tb.final_item = 0    --tb.ratio_items = {}endfunction GameSceneHandleFight.init()	mIsGameOver = false	mMonsterTable = {}	mBuffInfoTable = {}	mHaloTable = {}	restorePlayerArr()	local playerArr = ModelPlayer.getPlayerAllAttr()	mPlayerAttribute.life = playerArr.life	mPlayerAttribute.haloStepCount = 0	--Lewis:spriteShaderEffect(ModelPlayer:getPlayerNode(), "none", false)endfunction GameSceneHandleFight.initSkill(layer)	GameSkillMgr.setStartBuffEffectListener(startBuffWithTarget)	GameSkillMgr.setAutoStartSkillStartListener(autoStartSkillStartListener)		print("show skill id++++++++++++++++++++++++++++++++++++++++")	GameSkillMgr.init(ModelRune.getRuneIDTable())	GameSkillBarLayer.create(layer)		local skillBackLayer = CCLayer:create()	layer:addChild(skillBackLayer, 100)		local skillFrontLayer = CCLayer:create()	layer:addChild(skillFrontLayer, 99)	GameSkillEffectLayer.create(layer, skillFrontLayer, skillBackLayer)	restorePlayerArr()	GameSkillMgr.step("normal")	print("i am in position+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")endfunction GameSceneHandleFight.isunControllable()	return mIsPlayAnimationend--注册战斗主线副本校验NetSocket_registerHandler(NetMsgType["msg_notify_game_settle"], notify_game_settle(), Handle_player_req_game_settle)--注册战斗主线副本校验NetSocket_registerHandler(NetMsgType["msg_notify_push_tower_map_settle"], notify_push_tower_map_settle(), Handle_player_req_game_settle)-- 竞技战斗结算NetSocket_registerHandler(NetMsgType["msg_notify_challenge_settle"], notify_challenge_settle(), Handle_player_req_game_settle)