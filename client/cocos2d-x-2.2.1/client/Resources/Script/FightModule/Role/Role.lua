------------------------------------------------------------------------ 作者：lewis-- 日期：2013-3-31-- 描述：角色基类----------------------------------------------------------------------Role = class()local ROLE_ID = 1--构造函数function Role:ctor()	self.mData 					= RoleData.new()	--数据	self.mRoleView 				= nil		--角色视图	self.mInfoView				= nil		--属性视图	self.mPosition				= ccp(0, 0)		--弹道	self.mBallistic					= {}	self.mBallistic.flyId 		= 0	self.mBallistic.frontId 	= 0	self.mBallistic.backId 		= 0	self.mConfigTB				= {}end-----------------------------------------------------------------------------------------------------------配置数据----------------------------------------------------------------------------------------------------------------初始化配置数据function Role:initConfig()    Log()    self.tag = nil                          --判断子类类型    self.mConfigTB["role_id"]  = ROLE_ID    --实例ID    ROLE_ID = ROLE_ID + 1    self.mConfigTB["serve_role_id"]         = -1        --服务端实例ID    self.mConfigTB["is_leader"]             = 0         --默认为0,1表示团长	self.mConfigTB["role_group_id"]			= 0			--组别id,0是玩家,1是怪物,2是友军	self.mConfigTB["role_side_id"]			= 0			--属于哪一边的,0是玩家,1是敌人    --self.mConfigTB["role_infoViewRoot"]     = nil       --角色UI 根节点	self.mConfigTB["role_type"]				= 1			--职业id,1战士,2圣骑,3萨满,4法师	self.mConfigTB["role_icon_id"]			= 0			--icon	self.mConfigTB["grid_id"]				= 0			--所在的格子id	self.mConfigTB["role_nick_name"]		= "monster"	--名称	self.mConfigTB["role_level"]			= 0			--等级	self.mConfigTB["role_config"]			= {}		--配置数据    self.mConfigTB["role_talent"]			= {}		--角色天赋	self.mConfigTB["attack_type"]			= 0			--攻击类别,1为主动	self.mConfigTB["under_attack"]			= false		--被攻击中    self.mConfigTB["mitigation"]            = 0         --减伤		self.mConfigTB["specail_skill_id"]		= 0			--特殊技能id		self.mConfigTB["monster_type"]			= 0			--怪物类别		self.mConfigTB["is_knockout"]			= false		--是否被K.O		--一些特殊的配置参数	self.mConfigTB["skill_after_enter"]		= 0			--出场后使用的技能	self.mConfigTB["stay_round"]			= -1		--存活回合数,-1为一直都在    self.mConfigTB["explosive_round"]		= -1		--大于0 击杀就没有自爆  =0 就是死了 也有自爆	self.mConfigTB["skill_after_death"]		= 0			--死亡后使用的技能	self.mConfigTB["skill_weak_halo"]		= 0			--对敌人使用的虚弱光环技能	self.mConfigTB["respawn_count"]			= 0			--重生次数	self.mConfigTB["respawn_life_rate"]		= 1	self.mConfigTB["respawn_atk_rate"]		= 1	self.mConfigTB["summon_after_death"]	= 0			--死亡后召唤的怪物id	self.mConfigTB["frantic_rate"]			= 0			--狂化率,每损失多少生命率,增加多少攻击力率		self.mConfigTB["steal_coin_rate"]		= 0			--金币偷取率	self.mConfigTB["drop_out_coins"]		= 0			--金币掉落个数	self.mConfigTB["behavior_name"]			= "idle"	--形为名	self.mConfigTB["is_boss"]				= false		--是否是boss	self.mConfigTB["skill_cnt"]				= 0			--技能个数    self.mConfigTB["summon_monsterid"]			= -1		--召唤怪物    self.mConfigTB["summon_amount"]				= -1	    --召唤数量    self.mConfigTB["summon_round"]				= -1		--召唤间隔    self.mConfigTB["summon_round_count"]		= 0		    --召唤间隔计数    self.mConfigTB["separateBody_amount"]		= -1	    --分身数量    self.mConfigTB["separateBody_round"]		= -1		--分身间隔    self.mConfigTB["separateBody_count"]		= 0		    --间隔计数    self.mConfigTB["separateBody_damged"]		= 1.0		--分身额外伤害倍率    self.mConfigTB["separateBody_atk"]		    = 1.0		--分身额外攻击倍率    self.mConfigTB["separateBody_miss"]		    = 1.0		--分身额外闪避倍率    --吞噬    self.mConfigTB["devour_round"]		        = 0	    	--吞噬回合间隔    self.mConfigTB["devour_count"]		        = 0		    --吞噬回合计数    self.mConfigTB["devour_preatk"]		        = 0		    --每吞噬一个增加伤害百分比    	self.mConfigTB["stealth_available"]			= false		--潜行是否有效	self.mConfigTB["is_on_stealth"]				= false		--是否潜行中	self.mConfigTB["stealth_hide_round"]		= 0			--潜行隐身回合	self.mConfigTB["stealth_hide_count"]		= 0			--潜行隐身计数	self.mConfigTB["stealth_show_round"]		= 0			--潜行现身回合	self.mConfigTB["stealth_show_count"]		= 0			--潜行现身计数		self.mConfigTB["death_display_mode"]		= "normal"	--死亡表现模式        self.mConfigTB["is_separate"]	            = false    self.mConfigTB["real_body_id"]              = 0    self.mConfigTB["fast_respawn"]              = 1         end--获得数据function Role:getConfig(name)	local ret = self.mConfigTB[name]	return retend--设置数据function Role:setConfig(name, value)	self.mConfigTB[name] = valueend--更新数据function Role:updateConfig(name, value)	self.mConfigTB[name] = self.mConfigTB[name] + valueend-----------------------------------------------------------------------------------------------------------外部接口----------------------------------------------------------------------------------------------------------------清除function Role:cleanup()	if self.mRoleView == nil then		return	end	self.mRoleView:cleanup()	self.mRoleView = nilend--是否存亡function Role:isAlive()	local hitPoints = self.mData.mAttribute:getHitPoints()	return hitPoints > 0end--获得属性function Role:getDataInfo(name)	if name == "attr" then		return self.mData.mAttribute	elseif name == "buff" then		return self.mData.mBuff 	elseif name == "skill" then		return self.mData.mSkill	elseif name == "status" then		return self.mData.mStatus	end	return nilend--受到伤害,修改真实生命值function Role:bearDamage(damage)	--print("bear damage", damage)	self.mData.mAttribute:modifiedHitPoints(damage)end--结算伤害,伤害显示生命值function Role:settleDamage(damage)	if self:getConfig("is_knockout") then		return	end    local attr = self:getDataInfo("attr")	attr:modifiedWithName("life", damage)	local life = self.mData.mAttribute:getByName("life")	self:updateInfoView("attr")    --if self:getConfig("grid_id") == 0 then         --cclog("settleDamage","life:",life,"attr.hitPoints",attr.hitPoints,"gridId",self:getConfig("grid_id"))     --end	if life <= 0 and attr.hitPoints <= 0 then		self:knockout()		return	end		--驱动新手	if self:getConfig("role_group_id") == 0 then		GuideEvent.hurt()	endend--角色动作,角色想做什么,普通攻击，或使用技能function Role:getAction()	return nil--不做任何事end--更新属性视图function Role:updateInfoView(param)	if self:getConfig("is_knockout") then		return	end	if self.mInfoView == nil then		return	end	self.mInfoView:update(param)end--获得弹道function Role:getBallistic()	return self.mBallisticend--获得位置function Role:getPosition()	return ccp(self.mPosition.x, self.mPosition.y)end--获得顶部位置function Role:getBottomPos()	return ccp(self.mPosition.x, self.mPosition.y + 42)end--获得中间位置function Role:getMiddlePos()	return ccp(self.mPosition.x, self.mPosition.y + 94)end--获得头顶位置function Role:getTopPos()	return ccp(self.mPosition.x, self.mPosition.y + 128)end--改变动画状态function Role:changeAnimateState(name)	if self:getConfig("is_knockout") then		return	end	if name == "attack" then			--攻击		self.mRoleView:onAttack()	elseif name == "hit" then			--受击		self.mRoleView:onHit()	elseif name == "magic" then			--魔法		self.mRoleView:onMagic()	elseif name == "aimed" then			--技能锁定		self.mRoleView:onAimed(true)	elseif name == "dis_aimed" then		--取消锁定		self.mRoleView:onAimed(false)	elseif name == "baneling" then		--自爆		self.mRoleView:onBaneling()	endend--动作持续时间function Role:getDuration(name)	if name == "attack" then		return 0.25	elseif name == "hit" then		return 0.3	elseif name == "magic" then		return 0.25	end	return 0.5end--改变行为状态function Role:changeBehaviorState(name)	if self:getConfig("is_knockout") then		return	end	if name == "dodge" then		self.mRoleView:onDodge()	endend--改变buff颜色function Role:changeShader()	if self:getConfig("is_knockout") then		return	end	local shader = BuffMgr.getShader(self) --self.mData.mBuff:getShader()	self.mRoleView:onShader(shader)end--改变行为状态function Role:changePortraits()	if self:getConfig("is_knockout") then		return	end	local id = self.mData.mStatus:getStatus("hex")	self.mRoleView:onHex(id)end--计数+1function Role:onStep(name)	if name == "buff" then		--self.mData:buffStep()        BuffMgr.onStep(self)	elseif name == "skill" then		self.mData:skillStep()	endend--回合计算function Role:roundStep()	self:updateInfoView("attr")end--使用技能function Role:useSkill(id)	self.mData.mSkill:onUse(id)	self:updateInfoView("skill")end--角色被K.Ofunction Role:knockout()end--角色重生function Role:respawn()end--接受/失去_光环bufffunction Role:acceptHalo(buff,bOn)	--self.mData.mBuff:onHalo(caster.mData.mBuff, bOn, idx)    local modifyTB = buff:getBuffConfig("modifyTB")    local attr = self:getDataInfo("attr")    buff:modifyAttribute(self,modifyTB, bOn)	buff:modifyStatus(self,modifyTB, bOn)	self:updateInfoView("attr")end--取消选中所有技能function Role:unselectAllSkill()	self.mData.mSkill:unselectAllSkill()	self.mInfoView:unselectAllSkill()end-----------------------------------------------------------------------------------------------------------状态判定----------------------------------------------------------------------------------------------------------------是否可以攻击function Role:isCommonAttackValid()	local status = self.mData.mStatus	--是否被缴械 缴械 已无用	if status:getStatus("disarm") then		return false	end	--是否不可操作	if status:getStatus("uncontrollable") then		return false	end	--是否变成小动物	if status:getStatus("hex") ~= 0 then		return false	end	return trueendfunction Role:isStepSkill()	--是否不可操作	if status:getStatus("uncontrollable") then		return false	end	--是否变成小动物	if status:getStatus("hex") ~= 0 then		return false	end	return trueend --吸收伤害function Role:absorptDamage(damageValue)        local isAbsorpt = false        local status = self:getDataInfo("status")        local buffTb = self:getDataInfo("buff")        local absorptDp =  status:getStatus("absorption")   --剩余吸收数值        if absorptDp > 0 then             isAbsorpt = true            local lefeabsorptDp = absorptDp - damageValue             if lefeabsorptDp < 0 then                      status:setStatus("absorption",0)                damageValue = -lefeabsorptDp                --移除魔法盾buff                for key,buff in pairs(buffTb) do                     --魔法盾类型                    if buff:getBuffConfig("buff_replace_type") == 25 then                         table.remove(buffTb, key)                        break                    end                end                 self:updateInfoView("buff")            else                 status:setStatus("absorption",lefeabsorptDp)                damageValue = 0            end         end         return damageValue,isAbsorptend --初始化偷钱function Role:initStealCoin()	--偷取金币	local rate = self:getConfig("steal_coin_rate")	local total = FightDateCache.getData("fd_coin_count")	local coins = math.ceil(total * rate)	total = total - coins	FightDateCache.setData("fd_coin_count", total)	if coins > 0 then		self:setConfig("drop_out_coins", coins)		local effect = EffectStealConis.new()		effect:init(coins, self:getMiddlePos())		effect:play()	endend 