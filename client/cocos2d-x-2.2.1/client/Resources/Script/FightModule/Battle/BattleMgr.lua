------------------------------------------------------------------------ 作者：lewis-- 日期：2013-4-4-- 描述：战场管理器------------------------------------------------------------------------require "AIAutoPlay"--require "AIAutoPlayHelper"--require "AIMonster"--require "LogicFight"--require "LogicRound"require "Round"require "Damage"require "BehaviorInfo"require "BattleStep"require "StepAttacker"require "StepBallistic"require "StepDefender"require "StepRoleHurt"require "StepBeforeCast"require "StepPlayerCast"require "StepCaster"require "StepAfterCast"require "StepSkillEffect"require "StepAfterRoleSkill"require "StepAfterItemSkill"require "StepBaneling"require "StepPlayerBuff"require "StepMonsterBuff"require "StepUpdateSkill"require "StepRoleRound"require "StepEmpty"require "StepRoundShow"require "StepOpenGrid"require "CommonAttack"require "MagicAttack"require "FightFirstCopy"require "ItemSkill"BattleMgr = {}local mConfigTB = {}function BattleMgr.init()	mConfigTB = {}	mConfigTB["bmc_current_round"]				= nil		--当前回合	mConfigTB["bmc_round_timer_layer"]			= nil		--回合定时器	mConfigTB["bmc_damage_layer"]				= nil		--伤害信息显示层	mConfigTB["bmc_crit_rate"]					= 1.5		--暴击倍率	mConfigTB["bmc_overlapped_round"]			= true		--是否可重叠回合,如果是则当前有回合运行时，不可创建新的回合	mConfigTB["bmc_baneling_duration"]			= 1.25		--自爆延时时间end--获得数据function BattleMgr.getConfig(name)	local ret = mConfigTB[name]	return retend--设置数据function BattleMgr.setConfig(name, value)	mConfigTB[name] = valueend-----------------------------------------------------------------------------------------------------------回合启动----------------------------------------------------------------------------------------------------------------能否新启一个回合function BattleMgr.isNewRoundVaid()	local round = BattleMgr.getConfig("bmc_current_round")	if BattleMgr.getConfig("bmc_overlapped_round") == false then		if round ~= nil then			return false		end	end	return trueendfunction BattleMgr.talentStepOpenGrid()    --触发玩家开格子天赋天赋    local playerTB = RoleMgr.getConfig("rmc_player_table")	for key, player in pairs(playerTB) do		if player:isAlive() then            talentMgr.excultOnEvent(player,"OpenGrid",nil,nil,nil)		end	endend --玩家开格子function BattleMgr.playerOpenGrid(gridId)	local round = BattleMgr.newRound("open_grid", true)	BattleMgr.setConfig("bmc_current_round", round)    local player = RoleMgr.getConfig("rmc_player_object")    BattleMgr.openGridEventSet(player, gridId, "PLAYER_APPLY")    BattleMgr.talentStepOpenGrid()    BattleMgr.excultLogic()    --round = BattleMgr.getConfig("bmc_current_round")	round:run()		player:unselectAllSkill()end--攻击怪物function BattleMgr.attackMonster(gridId, bMask)	--查询格子上怪物	local monster = RoleMgr.getMonsterByGridId(gridId)	if monster == nil then		return	end	--怪物是否存活	if monster:isAlive() == false then		return	end	local player = RoleMgr.getConfig("rmc_player_object")	local friend = RoleMgr.getConfig("rmc_friend_object")	local caster = player	local skillId, level = player.mData.mSkill:getSelected()	--自身技能没选中,是否选了援军技能    local bFriendSkill = false	if skillId == 0 then		local dataSkill = AssistanceViewController.getConfig("data_skill")		if dataSkill then			skillId, level = dataSkill:getSelected()			caster = friend            bFriendSkill = true		end	end	if skillId == 0 then		if bMask == false then			local round = BattleMgr.newRound("fight", true)			BattleMgr.setConfig("bmc_current_round", round)            --竞技场点敌人无法 反击 速度失效 ！            if FightDateCache.getData("fd_game_mode") ~= 5 then 			    CommonAttack.fight(player, monster)            else                 CommonAttack.attack(player, monster)            end            BattleMgr.excultLogic()			round:run()		end	else        if bFriendSkill == false then            player:useSkill(skillId)        end		local round = BattleMgr.newRound("magic", false)		MagicAttack.fight(caster, monster, skillId, level)		round:run()	end	player:unselectAllSkill()end--主动技能function BattleMgr.autoSkill(caster, id, level)	local round = BattleMgr.newRound("magic", false)	local bRet = MagicAttack.fight(caster, nil, id, level)	round:run()	local player = RoleMgr.getConfig("rmc_player_object")	player:unselectAllSkill()    if bRet and caster == player then         player:useSkill(id)    endend--对玩家施放的道具技能,如血瓶function BattleMgr.itemSkillForPlayer(casterPos, id)	local round = BattleMgr.newRound("item_skill", false)	local player = RoleMgr.getConfig("rmc_player_object")    player:useSkill(id)	player:unselectAllSkill()	ItemSkill.fight(casterPos, player, id, 1)	round:run()endfunction BattleMgr.itemTrap(casterPos, id)    local round = BattleMgr.getConfig("bmc_current_round")
	if round == nil then      
		return BattleMgr.itemSkillForPlayer(casterPos, id)
	end    local player = RoleMgr.getConfig("rmc_player_object")    player:useSkill(id)	player:unselectAllSkill()	ItemSkill.fight(casterPos, player, id, 1)end----------------------------------------------------------------------------------------------------------回合逻辑---------------------------------------------------------------------------------------------------------------开格子事件聚合function BattleMgr.openGridEventSet(caster, gridId, openMode, timer)    local round = BattleMgr.getConfig("bmc_current_round")    if timer == nil then		timer = round:getLastTime()	end
    local step = nil
    --if  FightDateCache.getData("fd_game_mode") == 5 then 
	if  openMode == "AI_RANDOM" then 
        step = StepAttacker.new()	    step:init(caster)	    step:setTimer(timer)	    round:add(step)	    timer = timer + step:getDuration()

        local grid = GridMgr.getGridByIdx(gridId)

        --弹道飞行	    local ballistic = caster:getBallistic()	    step = StepBallistic.new()	    local flyId 	= ballistic.flyId	    local frontId 	= ballistic.frontId	    local backId	= ballistic.backId	    step:init(caster:getMiddlePos(), grid:getMiddlePos(), flyId, 0, 0)	    step:setTimer(timer)	    round:add(step)	    timer = timer + step:getDuration()

        local step = StepOpenGrid.new()	    step:init(openMode, gridId)	    step:setTimer(timer)	    round:add(step)
    else
        local grid = GridMgr.getGridByIdx(gridId)        grid:onEvent()
    end 

end--FIXMEfunction BattleMgr.showRoundProgres(flag)    if FightDateCache.getData("fd_game_mode") ~= 5 then --天梯赛才有这样设定       return    end 	local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()	local stepRoundshow = StepRoundShow.new()    stepRoundshow:init(flag)--enemyround	stepRoundshow:setTimer(timer+stepRoundshow:getDuration())	round:add(stepRoundshow)end --回合过程逻辑function BattleMgr.excultLogic()    if  FightDateCache.getData("fd_game_mode") == 5  then         FightDateCache.setData("fd_global_lockevent", true)    end    BattleMgr.talentStep("myRound")  --FIXME 区分敌我   BattleMgr.skillStep()   BattleMgr.friendAction()   BattleMgr.playersbuffLifeEffect()   BattleMgr.playerBuffStep()   --敌方回合   BattleMgr.showRoundProgres("enemyround")   BattleMgr.talentStep("enemyRound")    --BattleMgr.buffLifeEffect()   BattleMgr.monstersAction()   BattleMgr.monstersbuffLifeEffect()   BattleMgr.monsterBuffStep()   BattleMgr.totemAction()   BattleMgr.roundStep()   BattleMgr.showRoundProgres("myround")end --创建新的回合function BattleMgr.newRound(tag, bValid)	RoleMgr.aimedMonster(false)	--前一回合是否执行完	local round = BattleMgr.getConfig("bmc_current_round")	if round then		round:skip()		BattleMgr.setConfig("bmc_current_round", nil)	end	round = Round.new()	round:init(tag, bValid)	BattleMgr.setConfig("bmc_current_round", round)	return roundend--一回合结束function BattleMgr.roundEnd(round)	if round.mbValid then        RoleBoss_roundExcute()		FightMgr.nextRound()		AssistanceViewController.update()	end	if round.mName == "fight" then		GuideEvent.onFight()	elseif round.mName == "magic" then		GuideEvent.afterSkill()	end	BattleMgr.setConfig("bmc_current_round", nil)    local player = RoleMgr.getConfig("rmc_player_object")    --竞技场玩家死亡	if  FightDateCache.getData("fd_game_mode") == 5  then              local killFriendNumber = RoleMgr.getConfig("kill_friend_number")         local killEnemyNumber = RoleMgr.getConfig("kill_enemy_number")        if killFriendNumber>=3 or killEnemyNumber >=3 then             --比赛结束             return        end         if player:isAlive() ~= true and killFriendNumber < 3 then         	local round = BattleMgr.newRound("monster_round", true)		    BattleMgr.setConfig("bmc_current_round", round)		    local empty = StepEmpty.new()		    empty:setTimer(1.0)		    round:add(empty)            BattleMgr.excultLogic()		    round:run()            return        end     end 	--玩家被眩晕	if player:isCommonAttackValid() == false and player:isAlive() then    		local round = BattleMgr.newRound("monster_round", true)		BattleMgr.setConfig("bmc_current_round", round)		local empty = StepEmpty.new()		empty:setTimer(1.0)		round:add(empty)        BattleMgr.excultLogic()		round:run()	endend--flush还没完成的回合,一般点门的时候用function BattleMgr.flush()	local round = BattleMgr.getConfig("bmc_current_round")	if round then		round:skip()		BattleMgr.setConfig("bmc_current_round", nil)        lewisPrint("flush round")	endend--天赋stepfunction BattleMgr.talentStep(_flag)    if _flag == "myRound" then        local playerTB = RoleMgr.getConfig("rmc_player_table")	        for key, player in pairs(playerTB) do		        if player:isAlive() then                    --TalentStep.onTrigger(player)                    talentMgr.excultOnEvent(player,"RoundBegin",nil,nil)		    end	   end    elseif _flag == "enemyRound" then         local monsterTB 	= RoleMgr.getConfig("rmc_monster_table")	    for key, monster in pairs(monsterTB) do		    if monster:isAlive() then			    --TalentStep.onTrigger(monster)                talentMgr.excultOnEvent(monster,"RoundBegin",nil)		    end	    end    endend--更新技能function BattleMgr.skillStep()	local playerTB 		= RoleMgr.getConfig("rmc_player_table")	local monsterTB 	= RoleMgr.getConfig("rmc_monster_table")	for key, monster in pairs(monsterTB) do		if monster:isAlive() then			monster:onStep("skill")		end	end		for key, player in pairs(playerTB) do		if player:isAlive() then			player:onStep("skill")		end	end		local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()	timer = timer + 0.015	local step = StepUpdateSkill.new()	step:init()	step:setTimer(timer)	round:add(step)end--玩家更新bufffunction BattleMgr.playerBuffStep()	local playerTB 		= RoleMgr.getConfig("rmc_player_table")	for key, player in pairs(playerTB) do		if player:isAlive() then			player:onStep("buff")		end	end	local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()	timer = timer + 0.015	local step = StepPlayerBuff.new()	step:init()	step:setTimer(timer)	round:add(step)end--怪物更新bufffunction BattleMgr.monsterBuffStep()	local monsterTB 	= RoleMgr.getConfig("rmc_monster_table")	for key, monster in pairs(monsterTB) do		if monster:isAlive() then			monster:onStep("buff")		end	end	local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()	timer = timer + 0.015	local step = StepMonsterBuff.new()	step:init()	step:setTimer(timer)	round:add(step)end--buff怪物function BattleMgr.monstersbuffLifeEffect()	--local playerTB 		= RoleMgr.getConfig("rmc_player_table")	local monsterTB 	= RoleMgr.getConfig("rmc_monster_table")    local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()    timer = timer + 0.015	--怪物	for key, player in pairs(monsterTB) do		if player:isAlive() then			local buffTb = player.mData.mBuff            for key,buff in pairs(buffTb) do                 local lifeValue =  buff:modifyLifeValue(player)                if lifeValue ~= 0 and player:isAlive() then				    local damage = Damage.new()				    damage:setData("damage", lifeValue)				    damage:setData("type", "hit")								    player:bearDamage(damage:getData("damage"))				    local step = StepRoleHurt.new()				    step:init(player, damage)				    step:setTimer(timer+(key-1)*0.15)				    damage:setData("position", player:getTopPos())				    round:add(step)			    end            end  		end	end  end--buff的中毒或回复效果  玩家 function BattleMgr.playersbuffLifeEffect()   	local playerTB 		= RoleMgr.getConfig("rmc_player_table")	--local monsterTB 	= RoleMgr.getConfig("rmc_monster_table")    local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()    timer = timer + 0.015 	--玩家	for key, player in pairs(playerTB) do		if player:isAlive() then			local buffTb = player.mData.mBuff            for key,buff in pairs(buffTb) do                 local lifeValue =  buff:modifyLifeValue(player)                if lifeValue ~= 0 and player:isAlive() then				    local damage = Damage.new()				    damage:setData("damage", lifeValue)				    damage:setData("type", "hit")				    player:bearDamage(damage:getData("damage"))				    local step = StepRoleHurt.new()				    step:init(player, damage)				    step:setTimer(timer+(key-1)*0.15)				    damage:setData("position", player:getTopPos())				    round:add(step)			    end            end  		end	end  end--回合计数function BattleMgr.roundStep()	local playerTB 		= RoleMgr.getConfig("rmc_player_table")	local monsterTB 	= RoleMgr.getConfig("rmc_monster_table")	local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()	timer = timer + 0.015	for key, monster in pairs(monsterTB) do		if monster:isAlive() then			local step = StepRoleRound.new()			step:init(monster)			step:setTimer(timer)			round:add(step)		end	end		for key, player in pairs(playerTB) do		if player:isAlive() then			local step = StepRoleRound.new()			step:init(player)			step:setTimer(timer)			round:add(step)		end	end		local totemTB = RoleMgr.getConfig("rmc_totem_table")	for key, totem in pairs(totemTB) do		local step = StepRoleRound.new()		step:init(totem)		step:setTimer(timer)		round:add(step)	endend--新怪物动作 放技能function BattleMgr.friendAction()    local round = BattleMgr.getConfig("bmc_current_round")
    local timer = round:getLastTime()    --所有友方    local player = RoleMgr.getConfig("rmc_player_object")    local playerTb = RoleMgr.getConfig("rmc_player_table")     for key,playerInfo in pairs(playerTb) do         if playerInfo:isAlive() and playerInfo ~= player then             local _roleAction = playerInfo:getAction()            _roleAction:calcBehaviorTree(timer)           --_roleAction:excultBehaviorTree(timer)            timer = timer + 0.15        end    end end function BattleMgr.monstersAction()    local round = BattleMgr.getConfig("bmc_current_round")
    local timer = round:getLastTime()    timer = timer + 0.015    --所有敌方    local monsterTB 	= RoleMgr.getConfig("rmc_monster_table")    for key, monster in pairs(monsterTB) do        if monster:isAlive() then            local _roleAction = monster:getAction()            _roleAction:calcBehaviorTree(timer)            timer = timer + 0.15        end     end end --图腾动作function BattleMgr.totemAction()	local player = RoleMgr.getConfig("rmc_player_object")	local tb 	= RoleMgr.getConfig("rmc_totem_table")	local round = BattleMgr.getConfig("bmc_current_round")	local timer = round:getLastTime()	local duration = 0.15	for key, totem in pairs(tb) do		local target = nil		if totem:getConfig("tt_player_only") > 0 then			target = player		else			--图腾攻击怪物			local rate = totem:getConfig("tt_player_rate")			if math.random(0, 100) >= rate then				target = RoleMgr.getRandomMonster()			else				target = player			end			--不是只攻击怪物时,找不到怪物目标那只攻击玩家			if rate > 0 and target == nil then				target = player			end		end		--找到了攻击目标		if target then			local action = totem:getAction()--获得动作			local id 	= action:getConfig("skill_id")			local level = action:getConfig("skill_level")						local intimer = timer			--施法动作			local step = StepCaster.new()			step:init(totem, id)			step:setTimer(intimer)			round:add(step)			intimer = intimer + step:getDuration()			ItemSkill.fight(totem:getMiddlePos(), target, id, level, intimer)			timer = timer + duration		end	endend-----------------------------------------------------------------------------------------------------------数值计算----------------------------------------------------------------------------------------------------------------防御者受伤害,主要计算伤害转移function BattleMgr.defenderBearDamage(defender, fromDamage, timer)	local groupId = defender:getConfig("role_group_id")--组别id,0是玩家,1是怪物    local monsterTB = {}	if groupId == 0 then --玩家阵营        monsterTB = RoleMgr.getConfig("rmc_player_table")    else         monsterTB = RoleMgr.getConfig("rmc_monster_table")	end	--回血效果无效	local dp = fromDamage:getData("damage")	if dp >= 0 then		return	end	local effectId = 19		for key, monster in pairs(monsterTB) do		if defender ~= monster then			local status = monster.mData.mStatus			local redution = status:getStatus("human_shield_damage_reduce")			if redution > 0 and monster:isCommonAttackValid() and monster:isAlive() then				--清空当前受击者的伤害				fromDamage:setData("damage", 0)				fromDamage:setData("effect_id", effectId)				fromDamage:setData("desPos", monster:getTopPos())								--重新计算新的伤害				dp = math.ceil(math.abs(dp) * redution)				local damage = Damage.new()				damage:setData("damage", -dp)				damage:setData("type", "hit")				monster:bearDamage(damage:getData("damage"))								local round = BattleMgr.getConfig("bmc_current_round")				local step = StepRoleHurt.new()				step:init(monster, damage)				step:setTimer(timer)				damage:setData("position", monster:getTopPos())				round:add(step)				monster:setConfig("behavior_name", "human_shield")				return			end		end	endendfunction BattleMgr.fastRespawn(role, recoveHp)    local round = BattleMgr.getConfig("bmc_current_round")    local timer = round:getLastTime()    local attr = role:getDataInfo("attr")    local hp = recoveHp - attr.hitPoints    local damage = Damage.new()    damage:setData("damage", hp)    damage:setData("position", role:getTopPos())    damage:setData("behavior", "fm_chunge")    role:bearDamage(damage:getData("damage"))           --[[    local step = StepRoleHurt.new()    step:init(role, damage)	step:setTimer(timer)	round:add(step)    ]]--    local step = StepRoleHurtReswapn.new()    step:init(role, damage,recoveHp)	step:setTimer(timer)	round:add(step)end