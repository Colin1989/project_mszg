------------------------------------------------------------------------ 作者：lewis-- 日期：2013-4-4-- 描述：施法动作完毕后----------------------------------------------------------------------StepAfterCast = class(BattleStep)--构造function StepAfterCast:ctor()	self.mRole 		= nil		--施法角色    self.mTarget    = nil       --受击角色	self.mSkillId	= 0	self.mHealth	= health	self.mLevel		= 1	self.mName		= "after_cast"end--初始化function StepAfterCast:init(role, health, id, level,target,talentLv)	self.mRole = role    self.mTarget = target	self.mHealth = health	self.mSkillId = id	self.mLevel	= level    self.mTalentLv = talentLv or 0end--执行对应的操作function StepAfterCast:excute()	if self.mHealth ~= nil then		self.mRole:settleDamage(self.mHealth:getData("damage"))		self.mHealth:play()	end	--对施法者上buff	self:buffForCaster()end--为施法者上bufffunction StepAfterCast:buffForCaster()	if self.mRole == nil then		return	end	if self.mRole:isAlive() == false then		return	end		local base = SkillConfig.getSkillBaseInfo(self.mSkillId)	--几率计算	local config = SkillConfig.getSkillBuffInfo(base.caster_buff_id,base.quality,self.mLevel)	if config ~= nil then 		--buff几率计算        local bActiveBuff = nil        if self.mTalentLv >=1 then             bActiveBuff = SkillMgr.isOnBuff(base.quality, self.mLevel,             ParseExpressByTanletLv(self.mLevel,base.caster_buff_rate),self.mRole)        else             bActiveBuff = SkillMgr.isOnBuff(base.quality, self.mLevel,             ParseExpressByLv(self.mTalentLv,base.caster_buff_rate),self.mRole)        end 		if bActiveBuff then            BuffMgr.createFactory(base.caster_buff_id, base.quality, self.mLevel,self.mRole,self.mRole)			self.mRole:updateInfoView("buff")			self.mRole:updateInfoView("skill")            self.mRole:updateInfoView("attr")			self.mRole:changeShader()			self.mRole:changePortraits()		end	end    --为触发其他指定技能触发冷却    --[[    if #base.reset_skillkey > 0 then        for key,resetSkilltype in pairs(base.reset_skillkey) do             local skillData = self.mRole:getDataInfo("skill")            skillData:reset(resetSkilltype)        end         self.mRole:updateInfoView("skill")    end    ]]--    --为触发其他指定技能触发冷却    local  resetskillkeyTB = SkillConfig.getResetcdInfo(base.special_set,base.quality,self.mLevel,self.mTalentLv)    if resetskillkeyTB ~= nil then         for key,resetSkilltype in pairs(resetskillkeyTB) do             local skillData = self.mRole:getDataInfo("skill")            skillData:reset(resetSkilltype)        end         self.mRole:updateInfoView("skill")    end     --释放技能后召唤怪物    local summonid,amount = SkillConfig.getSummonInfo(base.special_set)    if summonid ~=nil then       GridMgr.skillSummon(tonumber(amount),tonumber(summonid),self.mLevel,self.mRole)    end     --释放技能后 沉默对手技能    local rate ,amount = SkillConfig.getSkillCounter(base.special_set)    if rate ~= nil then         if math.random(1,100) < rate then              local skillData  =  self.mTarget:getDataInfo("skill")             skillData:counterAmount(amount)             self.mTarget:updateInfoView("skill")        end    end end