------------------------------------------------------------------------ 作者：lewis-- 日期：2013-04-11-- 描述：地图,处理格子等逻辑----------------------------------------------------------------------require "Grid"require "GridDoor"require "GridBarrier"require "GridItem"require "GridMonster"require "GridEnemy"require "GridEmpty"require "GridBoss"require "GridBossBody"require "GridSummon"require "GridFactory"require "MapView"require "GridTouchEvent" GridMgr = {}function gridPrint(...)	if true then return end	print(...)end-----------------------------------------------------------------------------------------------------------功能函数----------------------------------------------------------------------------------------------------------------显示出门,并打开周边遮罩function GridMgr.closeDoor()	local tb = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		value:closeDoor()	endend--主动怪出场function GridMgr.run()	local tb = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		value:run()	endend--点击格子function GridMgr.onTap(idx)	--不能开启新回合	if BattleMgr.isNewRoundVaid() == false then		return	end	local grid = GridMgr.getGridByIdx(idx)	if grid == nil then		return	end	grid:onTap()end--长按格子function GridMgr.onPress(idx)	local grid = GridMgr.getGridByIdx(idx)	if grid == nil then		return	end    print(grid:getConfig("tag"),"GridMgr.onPress(idx)",grid.tag)	grid:onPress()end-----------------------------------------------------------------------------------------------------------配置数据--------------------------------------------------------------------------------------------------------------local mConfigTB = {}--初始化配置数据function GridMgr.initConfig()	mConfigTB = {}	mConfigTB["gmc_map_width"]				= 5			--地图横向格子数	mConfigTB["gmc_map_height"]				= 6			--地图纵向格子数	mConfigTB["gmc_map_table"]				= {}		--地图数据表	mConfigTB["gmc_grid_table"]				= {}		--格子表	mConfigTB["gmc_grid_width"]				= 114		--格子宽度	mConfigTB["gmc_grid_height"]			= 107		--格子高度		mConfigTB["gmc_map_scene_id"]			= 0			--场景地图id			mConfigTB["gmc_map_rect"]				= nil		--地图区域		mConfigTB["gmc_x_batch_node"]			= nil		--地图x	mConfigTB["gmc_untouchable_batch_node"]	= nil		--不可点	mConfigTB["gmc_effect_layer"]			= nil		--地图特效层	mConfigTB["gmc_item_layer"]				= nil		--地图道具层	mConfigTB["gmc_monster_layer"]			= nil		--怪物层	mConfigTB["gmc_tips_layer"]				= nil		--战斗信息提示层	mConfigTB["touch_disable_layer"]		= nil		--不可点提示层,batch node    mConfigTB["gmc_timmer"]                 = nil       --格子定时器	mConfigTB["gmc_touch_effect"]			= true		--点击是否有效end--获得数据function GridMgr.getConfig(name)	local ret = mConfigTB[name]	if ret == nil then		return	end	return retend--设置数据function GridMgr.setConfig(name, value)	mConfigTB[name] = valueend-----------------------------------------------------------------------------------------------------------数据操作----------------------------------------------------------------------------------------------------------------初始化function GridMgr.init()	GridMgr.initConfig()	local width 	= GridMgr.getConfig("gmc_map_width")	local height 	= GridMgr.getConfig("gmc_map_height")	local tb = GridMgr.getConfig("gmc_map_table")	--生成数据表	local idx = 1	for y = 1, height do		for x = 1, width do			local data = {}			data.tag = "empty"			data.x = x			data.y = y			data.idx = idx			data.usedata = nil			data.isKey = false			table.insert(tb, data)			idx = idx + 1		end	endend--重置function GridMgr.reset()	GridMgr.getConfig("gmc_timmer").stop()	GridMgr.init()endfunction GridMgr.cleanup()	GridMgr.stopTimer()end--解析地图数据function GridMgr.parse(map)	--绑定竞技场敌人数据	for key, value in pairs(map.enemy) do		GridMgr.bindData("enemy", value.pos, value)        RoleMgr.addFriendLifeInfo(value)        --print("life:",value.cur_life,"enemy------------------------------------------->",value.pos,value.team_tag)	end		--绑定怪物数据	for key, value in pairs(map.monster) do		GridMgr.bindData("monster", value.pos, value)	end      for key, value in pairs(map.boss) do        local cx, cy = GridMgr.gridIdToCoord(value.pos)        for x = -1, 1 do            for y = -1, 1 do                local id = GridMgr.coordToId(cx + x, cy + y)                if id == value.pos then                    GridMgr.bindData("boss", value.pos, value)                elseif id ~= -1 then                    GridMgr.bindData("boss_body", id, value.pos)                end            end        end    end	--绑定陷阱数据	for key, value in pairs(map.trap) do         cclog("itemTrap", value.pos, value.trapid)        value.trapid = 1002		GridMgr.bindData("item", value.pos, value.trapid)	end		--绑定道具数据	for key, value in pairs(map.award) do		GridMgr.bindData("item", value.pos, value.awardid)	end		--绑定障碍数据	for key, value in pairs(map.barrier) do		GridMgr.bindData("barrier", value, 0)	end		--绑定门数据	GridMgr.bindData("door", map.start, 0)		GridMgr.setConfig("gmc_map_scene_id", map.scene)		--设置钥匙数据	GridMgr.bindKey(map.key)end--对对应的格子绑定数据function GridMgr.bindData(tag, idx, usedata)	local tb = GridMgr.getConfig("gmc_map_table")	local data = tb[idx]	if data == nil then		return	end	data.tag = tag	data.usedata = usedataend--绑定钥匙所在位置function GridMgr.bindKey(idx)	local tb = GridMgr.getConfig("gmc_map_table")	local data = tb[idx]	if data == nil then		return	end	data.isKey = trueend--数据绑定后,生成格子function GridMgr.create()	local map = GridMgr.getConfig("gmc_map_table")	local tb = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(map) do		local grid = GridFactory.create(value.tag)		if grid == nil then			gridPrint("can't creat grid width tag: ", value.tag)			return		end		grid:setConfig("grid_id", value.idx)		grid:setConfig("x_index", value.x)		grid:setConfig("y_index", value.y)		grid:setConfig("has_key", value.isKey)		grid:bindData(value.usedata)		table.insert(tb, grid)	endend-----------------------------------------------------------------------------------------------------------搜索格子----------------------------------------------------------------------------------------------------------------两格子间的距离function GridMgr.girdDistance(fromID, toID)	local width 	= GridMgr.getConfig("gmc_map_width")	local height 	= GridMgr.getConfig("gmc_map_height")	local sx = fromID % width	local sy = math.floor(fromID / width)	local dx = toID % width	local dy = math.floor(toID / width)	return math.abs(dx - sx) + math.abs(dy - sy)endfunction GridMgr.gridIdToCoord(id)
    local width 	= 5
	local x = id % width
	local y = math.floor(id / width) +1
	
	if (id%width==0) then 	
		x = 5 
		y = y -1
	end 
    return x, y
end--地图坐标转换成格子idfunction GridMgr.posToGridId(x, y)	local rect = GridMgr.getConfig("gmc_map_rect")	if rect:containsPoint(ccp(x, y)) == false then return 0 end		local width 	= GridMgr.getConfig("gmc_map_width")	local height 	= GridMgr.getConfig("gmc_map_height")		local cell_W = rect.size.width / width	local cell_H = rect.size.height / height	local line =(math.abs(x - rect.origin.x)) / cell_W	local row = (math.abs(y - rect.origin.y)) / cell_H	local gridId = math.floor(line) + width * (width - math.floor(row)) + 1	return gridIdend--通过idx索引格子数据function GridMgr.getGridByIdx(idx)	local tb = GridMgr.getConfig("gmc_grid_table")	if idx < 1 or idx > #tb then		gridPrint("get grid width invalid idx", idx)		return nil	end	return tb[idx]endfunction GridMgr.coordToId(cx, cy)    local width 	= GridMgr.getConfig("gmc_map_width")	local height 	= GridMgr.getConfig("gmc_map_height")	if (cx < 1 or cx > width) or (cy < 1 or cy > height) then		return -1	end	local idx = cx + (cy - 1) * width    return idxend--通过地图坐标索引格子数据function GridMgr.getGridByCoord(cx, cy)	local width 	= GridMgr.getConfig("gmc_map_width")	local height 	= GridMgr.getConfig("gmc_map_height")	if (cx < 1 or cx > width) or (cy < 1 or cy > height) then		return nil	end	local idx = cx + (cy - 1) * width	return GridMgr.getGridByIdx(idx)end--四个方向偏移local mFourDirection = {	{offx = -1, offy = 0},	{offx = 0, offy = 1},	{offx = 1, offy = 0},	{offx = 0, offy = -1},}--十字搜索function GridMgr.traversalByFourDir(sx, sy, dir)	local cx = sx + mFourDirection[dir].offx	local cy = sy + mFourDirection[dir].offy	return GridMgr.getGridByCoord(cx, cy)end--八个方向偏移local mEightDirection = {	{offx = -1, offy = 0},	{offx = -1, offy = 1},	{offx = 0, offy = 1},	{offx = 1, offy = 1},	{offx = 1, offy = 0},	{offx = 1, offy = -1},	{offx = 0, offy = -1},	{offx = -1, offy = -1},}--八个方向搜索function GridMgr.traversalByEightDir(sx, sy, dir)	local cx = sx + mEightDirection[dir].offx	local cy = sy + mEightDirection[dir].offy	return GridMgr.getGridByCoord(cx, cy)end--开如搜索,清除搜索标记function GridMgr.startSearch()end--物品掉落效果function GridMgr.actionDropDown(node, distance)	local act1 = CCEaseBackInOut:create(CCMoveBy:create(0.3, CCPointMake(0, -distance)))	local act2 = CCFadeIn:create(0.3)	local action = CCSpawn:createWithTwoActions(act2, act1)	node:runAction(action)end--------------------------------------------------------------------------------------------------------与角色管理器的接口---------------------------------------------------------------------------------------------------------格子上怪物被K.O --bBody 是否留下尸体function GridMgr.knockout(gridId, summonId, bBody)	local grid = GridMgr.getGridByIdx(gridId)	grid:knockout(summonId, bBody)end--function GridMgr.separate(gridId)    local grid = GridMgr.getGridByIdx(gridId)	grid:separate(summonId, bBody)end--是否可以点击格子function GridMgr.isTouchEnable()	return RoleMgr.isTouchEnable()end------------------------------------------------------------------------------------------------------------获取格子---------------------------------------------------------------------------------------------------------------获得格子位置function GridMgr.getPoistionByGridId(gridId)	local grid = GridMgr.getGridByIdx(gridId)	return grid:getPosition()end--获取格子上的怪物function GridMgr.getMonsterByGridId(gridId)    local grid = GridMgr.getGridByIdx(gridId)    return grid.mMonsterRoleend --获得门的位置function GridMgr.getDoorPos()	local tb = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		if value:getConfig("tag") == "door" then			return value:getPosition()		end	end	return ccp(360, 540)end--显示出门,并打开周边遮罩function GridMgr.openDoor()	local tb = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		value:openDoor()	endend--通过函数给定随机的格子function GridMgr.getGridByCandition(canditionFunc)	local tb = GridMgr.getConfig("gmc_grid_table")	local total = #tb	--先给定随机数	local idx = math.random(1, #tb)	local grid = GridMgr.getGridByIdx(idx)	if canditionFunc(grid) then		return grid	end		--搜索随机数附近最靠近并满足条件的格子	local cnt = total	local idx_up = idx	local idx_down = idx	for i = 1, cnt do		idx_up = idx_up + 1		idx_down = idx_down - 1		if idx_up <= total then			local grid = GridMgr.getGridByIdx(idx_up)			if canditionFunc(grid) then				return grid			end		end		if idx_down > 0 then			local grid = GridMgr.getGridByIdx(idx_down)			if canditionFunc(grid) then				return grid			end		end	end	return nilend--设置搜索标记function GridMgr.setSearchTag(tag)	local tb = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		value:setConfig("search_tag", tag)	endend--搜索爆炸格子的目标function GridMgr.getBombGridTargets(cnt)	GridMgr.setSearchTag(false)	--搜索函数	local function canditionFunc(grid)		if grid:getConfig("search_tag") then			return false		end		if grid:getConfig("is_opened") then			return false		end			if grid:getConfig("enable_force_open") == false then			return false		end		return true	end		local targets = {}	for i = 1, cnt do		local grid = GridMgr.getGridByCandition(canditionFunc)		local unit = {}		if grid then			grid:setConfig("search_tag", true)			unit.gridId = grid:getConfig("grid_id")			unit.pos	= grid:getPosition()		else			unit.gridId = 0			unit.pos	= ccp(0, 0)		end		table.insert(targets, unit)	end	return targetsend--获取可召唤的格子function GridMgr.getSummonGrids(amout)	GridMgr.setSearchTag(false)	--条件函数	local function canditionFunc(grid)		if grid:getConfig("search_tag") then			return false		end		if grid:getConfig("is_opened") == false  then			return false		end		if grid:getConfig("is_invalid") == false then			return false		end		return true	end		local targets = {}	for i = 1, amout do		local grid = GridMgr.getGridByCandition(canditionFunc)		local unit = {}		if grid then			grid:setConfig("search_tag", true)			table.insert(targets, grid:getConfig("grid_id"))		end	end	return targetsend------------------------------------------------------------------------------------------------------------外部逻辑---------------------------------------------------------------------------------------------------------------怪物吞噬 宿主怪物function GridMgr.devourAll(hostMonster)    local pRet = false    local posList = {}	local tb = RoleMgr.getConfig("rmc_monster_table")    local hostLv = hostMonster:getConfig("role_level")   	for key, rolemonster in pairs(tb) do		if rolemonster:isAlive() and rolemonster:getConfig("role_level") < hostLv  then			 rolemonster:cleanupIllusion()             table.insert(posList, rolemonster:getMiddlePos())             pRet = true		end	end        if pRet == true then         local attribute1 = hostMonster:getDataInfo("attr")        attribute1:modifiedMaxAttrByName("atk", #posList*hostMonster:getConfig("devour_preatk"))        hostMonster:updateInfoView("attr")    end    return pRet,posListend--怪物分身function GridMgr.separateMonster(amout, monster)    local tb = GridMgr.getSummonGrids(amout)    if #tb < amout then         cclog("格子不够 无法分身")        return false    end      --至空当前格子    --local newGrid = GridFactory.create("empty")    local gridTB = GridMgr.getConfig("gmc_grid_table")	--local oldGrid = gridTB[curGridId]    --oldGrid:copy(newGrid)    --gridTB[monster.mGridId] = newGrid    local attribute = monster:getDataInfo("attr")    local hitPoints = attribute.hitPoints    local life = attribute:getMaxAttrWithName("life")    local dp = hitPoints - life    local roleId = monster:getConfig("role_id")    --    local tb = GridMgr.getSummonGrids(amout)    local data = {}	data.monsterid 	= monster.mMonsterId	data.dropout 	= {}    local idx = math.random(1, #tb)    local posList = {}	for key, _gridId in pairs(tb) do		local newGrid = GridFactory.create("monster")        local oldGrid = gridTB[_gridId]		oldGrid:copy(newGrid)		newGrid:setConfig("tag", "monster")        newGrid:setConfig("is_invalid", false)		newGrid:bindData(data)		newGrid:mantaStyle()		gridTB[_gridId] = newGrid        local newMonster = RoleMgr.getMonsterByGridId(_gridId)        newMonster:bearDamage(dp)        newMonster.mData.mAttribute:modifiedWithName("life", dp)        table.insert(posList, newGrid:getMiddlePos())        if key == idx then            cclog("real body grid id", _gridId)            newMonster:setConfig("role_id", roleId)            newGrid:setConfig("is_summon_monster", false)        else            newGrid:setConfig("is_summon_monster", true)            newMonster:setConfig("is_separate", true)            newMonster:setConfig("real_body_id", roleId)            newMonster.mData.mStatus:setStatus("status_amplify_damage", newMonster:getConfig("separateBody_damged"))            local attribute1 = newMonster:getDataInfo("attr")            attribute1:modifiedMaxAttrByName("atk", newMonster:getConfig("separateBody_atk"))            attribute1:modifiedMaxAttrByName("miss_ratio", newMonster:getConfig("separateBody_miss"))        end        newMonster:updateInfoView("attr")	end    return true,posListend --在已打开的空白格子上召唤怪物(永久)function GridMgr.summonMonster(amout, monsterid,caster)	local tb = GridMgr.getSummonGrids(amout)	if #tb == 0 then		return	end	local data = {}	data.monsterid 	= monsterid	data.dropout 	= {}	local gridTB = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		local newGrid = GridFactory.create("monster")		local oldGrid = gridTB[value]		oldGrid:copy(newGrid)		newGrid:setConfig("tag", "monster")		newGrid:setConfig("is_summon_monster", true)        newGrid:setConfig("is_invalid", false)		newGrid:bindData(data)        newGrid:summonMonster(caster)		gridTB[value] = newGrid	endend--触发技能召唤function GridMgr.skillSummon(amout,summonMonsterid,level,caster)	local tb = GridMgr.getSummonGrids(amout)	if #tb == 0 then		return	end	local data = {}	data.monsterid 	=  tonumber(getSummonInfoById(summonMonsterid).monster_id)	data.dropout 	= {}	local gridTB = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		local newGrid = GridFactory.create("summon")		local oldGrid = gridTB[value]		oldGrid:copy(newGrid)		newGrid:setConfig("tag", "monster")		newGrid:setConfig("is_summon_monster", true)        newGrid:setConfig("is_invalid", false)		newGrid:bindData(data)        newGrid:summonMonster(caster,summonMonsterid,level)		gridTB[value] = newGrid	endend--强行打开格子function GridMgr.forceOpenGrid(gridId)	local grid = GridMgr.getGridByIdx(gridId)	if grid == nil then		return	end	grid:forceOpenGrid()end--强制打开所有没开过的格子function GridMgr.forceOpenAllGrid()	local tb = GridMgr.getConfig("gmc_grid_table")	for key, grid in pairs(tb) do        grid:openFogMask()		grid:forceOpenGrid()	endend function GridMgr.stopTimer()    local timer = GridMgr.getConfig("gmc_timmer")	if timer then timer.stop() endend --重置格子闪烁时间function GridMgr.resetTimer()    if GridMgr.getConfig("gmc_timmer") ~= nil then         GridMgr.stopTimer()         local allGrid = GridMgr.getConfig("gmc_grid_table")         for k, v in pairs(allGrid) do               if v:getConfig("isBright") == true then                     Lewis:spriteShaderEffect(v:getConfig("sprite_bg_mask"), "blank_grid.fsh", false)					v:setConfig("isBright",false)              end           end         MapView.createTimer()    end end--function GridMgr.summonItem(id)    local tb = GridMgr.getSummonGrids(1)	if #tb == 0 then		return	end	local data = id	local gridTB = GridMgr.getConfig("gmc_grid_table")	for key, value in pairs(tb) do		local newGrid = GridFactory.create("item")		local oldGrid = gridTB[value]		oldGrid:copy(newGrid)		newGrid:setConfig("tag", "item")        newGrid:setConfig("is_invalid", false)		newGrid:bindData(data)        newGrid:summonItem()		gridTB[value] = newGrid	endend