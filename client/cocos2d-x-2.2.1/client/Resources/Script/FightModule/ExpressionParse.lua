------------------------------------------------------------------------ 作者：lewis-- 日期：2013-04-17-- 描述：表达式解析----------------------------------------------------------------------ExpressionParse = {}local function localPrint(...)	if true then return end	lewisPrint("ExpressionParse", ...)endlocal mFunctionTB = {	{name = "pow", paramCount = 2},	{name = "pow_int", paramCount = 2},	{name = "floor", paramCount = 2},	{name = "ceil", paramCount = 1},	{name = "round", paramCount = 1},	{name = "abs", paramCount = 1},}local function isKeyWords(words)	for key, value in pairs(mFunctionTB) do		if value.name == words then			return value.paramCount		end	end	return 0end--通过变量表获值local function getValue(valueTable, name)	for key, element in pairs(valueTable) do		if element.name == name then			return element.value		end	end	return nilend--字符拆分并替换变量为对应的值local function strDivide(str, valueTable)	local newstr = string.gsub(str, "%s+", "")	local newTB = {}	for k,v in string.gmatch(newstr, "([A-Za-z0-9_.]*)([,()+*-/]?)") do		--字符		if k ~= "" then			local unit = {}			unit.value = k			local value = tonumber(k)			--不能转换成数字			if value == nil then				local paramCount = isKeyWords(k)				if paramCount > 0 then					unit.name = "function"					unit.functionName = k					unit.value = paramCount				else					value = getValue(valueTable, k)					if value == nil then						localPrint("bind value error!")						return nil					end					unit.name = "number"					unit.value = value				end			else				unit.name = "number"				unit.value = value			end			table.insert(newTB, unit)		end		--符号		if v ~= "" then			local unit = {}			unit.name = "symbol"			unit.value = v			table.insert(newTB, unit)		end	end	return newTBend--计算后缀表达式local function calExprTB(expr)	--dumpExpr(expr)	local result = {}		--结果表	local resultIndex = 0	--为结果表分配20空间	for i = 1, 40 do		table.insert(result, i)	end		for k, v in pairs(expr) do		if v.name == "number" then			resultIndex = resultIndex + 1			result[resultIndex] = v.value		elseif v.name == "symbol" then			if v.value == "+" then		--'+'				--不够两个操作数				if resultIndex < 2 then					result[resultIndex] = result[resultIndex]				else					result[resultIndex - 1] = result[resultIndex - 1] + result[resultIndex]					resultIndex = resultIndex - 1				end			elseif v.value == "-" then	--'-'				--不够两个操作数				if resultIndex < 2 then					result[resultIndex] = -result[resultIndex]				else					result[resultIndex - 1] = result[resultIndex - 1] - result[resultIndex]					resultIndex = resultIndex - 1				end			elseif v.value == "*" then	--'*'				result[resultIndex - 1] = result[resultIndex - 1] * result[resultIndex]				resultIndex = resultIndex - 1			elseif v.value == "/" then	--'/'				result[resultIndex - 1] = result[resultIndex - 1] / result[resultIndex]				resultIndex = resultIndex - 1			end		end	end	--localPrint(result[resultIndex])	return result[resultIndex]end--解析函数function ExpressionParse.parseFunction(strTB, functionName, count)	local unit = strTB[1]	table.remove(strTB, 1)			local paramCount = count	if unit.name ~= "symbol" and unit.value ~= "(" then		return -1	end		local resultTB = {}	local leftBrackets = 0--左括号数	local expr = {}	while paramCount > 0 do		if #strTB == 0 then return -1 end--表达试有误		local bEnd = false		local nextUnit = strTB[1]		table.remove(strTB, 1)		if nextUnit.name == "function" then--函数中有函数,开始递归			local data = {}			data.name = "number"			data.value = ExpressionParse.parseFunction(strTB, nextUnit.functionName, nextUnit.value)			table.insert(expr, data)		elseif nextUnit.name == "number" then			table.insert(expr, nextUnit)		elseif nextUnit.name == "symbol" then			if nextUnit.value == "(" then				leftBrackets = leftBrackets + 1                table.insert(expr, nextUnit)			elseif nextUnit.value == ")" then				if leftBrackets == 0 then					paramCount = 0					bEnd = true				else					table.insert(expr, nextUnit)				end				leftBrackets = leftBrackets - 1			elseif nextUnit.value == "," then				bEnd = true			else				table.insert(expr, nextUnit)			end		end		--一个参数表达式结束		if bEnd then			paramCount = paramCount - 1			local result = ExpressionParse.parseExpr(expr)			table.insert(resultTB, result)			expr = {}		end	end		local result = 0	--localPrint(functionName, count, result, resultTB[1], resultTB[2])	if functionName == "pow" then		result = math.pow(resultTB[1], resultTB[2])	elseif functionName == "pow_int" then		result = math.floor(math.pow(resultTB[1], resultTB[2]))	elseif functionName == "floor" then		if resultTB[2] == nil then			result = math.floor(resultTB[1])		else			result = math.floor(resultTB[1] / resultTB[2]) * resultTB[2]		end	elseif functionName == "ceil" then		result = math.ceil(resultTB[1])	elseif functionName == "round" then		local interget = math.floor(resultTB[1])		local tail = resultTB[1] - interget		if tail >= 0.5 then			interget = interget + 1		end		result = interget	elseif functionName == "abs" then		result = math.abs(resultTB[1])	end	--localPrint(functionName, result)	return resultendfunction ExpressionParse.parseExpr(strTB)	local expr = {}			--后缀表达式表	local symbol = {}		--符号表	local sidx = 0	local function addSymbol(symbolValue)		local data = {}		data.name = "symbol"		data.value = symbolValue		table.insert(expr, data)	end			while true do		if #strTB == 0 then break end		local unit = strTB[1]		table.remove(strTB, 1)		if unit.name == "number" then	--数字			table.insert(expr, unit)		elseif unit.name == "function" then--函数解析			local data = {}			data.name = "number"			data.value = ExpressionParse.parseFunction(strTB, unit.functionName, unit.value)			table.insert(expr, data)		elseif unit.name == "symbol" then --运算符			if unit.value == "(" then								--判断是否为左括号				sidx = sidx + 1				symbol[sidx] = unit.value			elseif unit.value == ")" then								--判断是否为右括号				while symbol[sidx] ~= "(" do--找到最近的左括号,并把其中的运算符进栈					addSymbol(symbol[sidx])					sidx = sidx - 1				end				sidx = sidx - 1--左括号出栈			elseif unit.value == "+" or unit.value == "-" then				--判断是否为加减号				while sidx >= 1 and symbol[sidx] ~= "(" do					addSymbol(symbol[sidx])					sidx = sidx - 1				end				sidx = sidx + 1				symbol[sidx] = unit.value			elseif unit.value == "*" or unit.value == "/" then				--同优先级的先进栈				while symbol[sidx] == "*" or symbol[sidx] == "/" do					addSymbol(symbol[sidx])					sidx = sidx - 1				end				sidx = sidx + 1				symbol[sidx] = unit.value			end 		end	end		--把符号表中余下的进栈	while sidx > 0 do		addSymbol(symbol[sidx])		sidx = sidx - 1	end	return calExprTB(expr)end--计算值function ExpressionParse.compute(formula, valueTable)	--localPrint("formula", formula)	local strTB = strDivide(formula, valueTable)	local result = ExpressionParse.parseExpr(strTB)	return resultend--[[local function test()	local valueTable = 	{		{name = "Quality", 	value = 2},		{name = "Lev", 	value = 5},		{name = "Exp", value = 1},	}	--local str = "(1-(Q-3)*(5-L))*20.1-(3*0.1)"	--local str = "pow(Q+pow_int(2+pow(3,1), 5*5-25+1),abs(1+3*0+1-L))"	local Quality = 2	local Lev = 5	local Exp = 1	local test = math.floor(2/Quality)*math.floor(Quality/2)*20+math.floor(3/Quality)*math.floor(Quality/3)*50+math.floor(4/Quality)*math.floor(Quality/4)*100+math.floor(5/Quality)*math.floor(Quality/5)*700+math.floor(6/Quality)*math.floor(Quality/6)*200010*(Quality-1)+Exp+50*math.pow(2,Quality+Lev-3)*math.ceil(Lev/(Lev+1))	localPrint(test)	local str = "floor(2/Quality)*floor(Quality/2)*20+floor(3/Quality)*floor(Quality/3)*50+floor(4/Quality)*floor(Quality/4)*100+floor(5/Quality)*floor(Quality/5)*700+floor(6/Quality)*floor(Quality/6)*200010*(Quality-1)+Exp+50*pow_int(2,Quality+Lev-3)*ceil(Lev/(Lev+1))"	local strTB = strDivide(str, valueTable)	local result = ExpressionParse.parseExpr(strTB)	localPrint(result)endtest()--"50.1*pow_int(abs(2),Quality+Lev-2)")]]--