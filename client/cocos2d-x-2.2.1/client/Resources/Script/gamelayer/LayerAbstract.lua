------------------------------------------------------------------------ 作者：shenl-- 日期：2013-12-27-- 描述：一切界面的基类（表）每个layer必须继承 LayerAbstract----------------------------------------------------------------------LayerAbstract = {}local mTargetName = nilLayerAbstract.Timer = false--创建视图之前的一些初始化,如资源预加载function LayerAbstract.loadResource()	cclog("Please implementation function.loadResource in you layer")endLayerAbstract.init = function()	cclog("Please implementation function.init in you layer")endLayerAbstract.onLayerForResult = function()	cclog("Please implementation function.onLayerForResult in you layer")endLayerAbstract.onClick = function(weightName)	cclog("Please implementation function.onClick in you layer")endLayerAbstract.onItemClick = function(parentNode,pos)	cclog("Please implementation function.onItemClick in you layer")endLayerAbstract.update = function(dt)	cclog("Please implementation function.update in you layer")endLayerAbstract.destroy = function()	cclog("Please implementation function.onDestory in you layer")end-----继承 function LayerAbstract:extend(childLayer)    childLayer = childLayer or {}    setmetatable(childLayer, self)    self.__index = self;endfunction onClickEvent(typeName,widget)		local CurTopLayerName = UIManager.getTopLayerName()			if typeName == "releaseUp" then			cclog("CurTopLayerName:",CurTopLayerName)			UIManager_UItable[CurTopLayerName].tb.onClick(widget)		endendlocal TIME_INTERVAL = 0.5local DoubleTimmer = nillocal function handleClearData()	DoubleTimmer = nilend--按钮双击事件function SetDoubleClickListenner(widget,callDouble,callSingle)	if nil == DoubleTimmer then		DoubleTimmer = CreateTimer(TIME_INTERVAL, 1, nil ,function(dt)			if dt ~= nil then 				dt.stop()				dt.setParam(nil)			end 		end)	end	local function EventScript(EventType,widget)		if EventType == "pushDown" then 			if DoubleTimmer.getParam() == widget:getName() then 				if callDouble ~= nil and type(callDouble) == "function" then 					callDouble(widget)	--双击触发事件				end				DoubleTimmer.stop()				DoubleTimmer.setParam(nil)			else 				DoubleTimmer.start()				DoubleTimmer.setParam(widget:getName())			end 		elseif EventType == "releaseUp" then 			if callSingle ~= nil  and type(callSingle) == "function" then 				callSingle(widget)			end 		end 	end 	widget:registerEventScript(EventScript)end EventCenter_subscribe(EventDef["ED_CLEAR_DATA"], handleClearData)-- 设置widget水平居中于父节点function setWidget_Horizontal_Center(widget)	local parentNode = widget:getParent()	local w = parentNode:getContentSize().width	local h = parentNode:getContentSize().height	local AncPos = parentNode:getAnchorPoint()	local pos = widget:getPosition()	widget:setAnchorPoint(ccp(0.5,0.5))	widget:setPosition(ccp(w/2 - AncPos.x*w,pos.y))end -- 更新需要时时监听的数据 一般用于倒计时 每隔0.5秒调用一次-- 用法：开启update tb.Timer = truelocal TimeInterval = 0UI_UPDATE_INTERVAL = 1.0function UILayerDateUpdate(dt)	TimeInterval = TimeInterval + dt	if TimeInterval > UI_UPDATE_INTERVAL then		for key,value in pairs(UIManager_UItable) do			if value.tb == nil then 				--cclog("ERROR:--------->",key)				return			end			if value.tb.Timer == true then				value.tb.update(TimeInterval)			end		end		TimeInterval = 0	endend---注册 weight事件function setOnClickListenner(weightName)	local weight = UIManager.getTopLayer():getWidgetByName(weightName)	weight:registerEventScript(onClickEvent)end-- 将数据和listView控件绑定-- 参数：scrollView 父节点  --		 ArrayDate 数据表 type（table）key 1,2,3..value :widget--   	 style "V" 代表竖方向滑动 style "H" 横向滑动--		 this,type(table) 当前界面表-- 用这个方法必须 继承 LayerAbstract  并且 实现 this.onItemClickfunction setListViewAdapter(this,scrollView,ArrayDate,style)  --横的要再优化情况不够的状态	tolua.cast(scrollView,"UIScrollView")	local DateLength = #ArrayDate	local ScrollSizeHeight = scrollView:getSize().height --可视范围	local ScrollSizeWidth  = scrollView:getSize().width		--cclog("~~~~~~~~~~~~~~~~~~~~~~~~~",scrollView:getSize().height)		local widgetWidth = 0;widgetHeight = 0	for key,widget in pairs(ArrayDate) do 		local widget_height = widget:getSize().height		local widget_width  = widget:getSize().width		local delta_H_anc = 0		local delta_W_anc = 0		if style =="V" then		--竖的			--自动往上拉			if ScrollSizeHeight - widget_height*DateLength > 0 then				local deltaH = ScrollSizeHeight - widget_height*DateLength				delta_H_anc = deltaH/widget_height			end			-- 居中			if widget_width - ScrollSizeWidth < 0 then				local deltaW = (ScrollSizeWidth - widget_width)/2					delta_W_anc = deltaW/widget_width			end			widgetHeight  = widgetHeight + widget:getSize().height			widget:setAnchorPoint(ccp(0 - delta_W_anc,(-1)*(key -1 + delta_H_anc)))			widget:setTag(DateLength - key)		elseif style =="H" then  --横的            local wightNodeWidth = 94			widgetWidth  = widgetWidth + wightNodeWidth --widget:getSize().width 			--widget:setAnchorPoint(ccp((-1)*(key -1),0))            widget:setPosition(ccp(            (key-1)*wightNodeWidth + widget:getSize().width/2,            widget:getSize().height/2))			widget:setTag(key-1)		end		--widget:setTouchEnabled(true)        if this ~= nil then 		    widget:registerEventScript(function (EventType,widge)			    if EventType == "releaseUp" then				    this.onItemClick(scrollView,widget:getTag())			    end		    end)        end 		scrollView:addChild(widget)	end		if style =="V" then			scrollView:setDirection(SCROLLVIEW_DIR_VERTICAL)		scrollView:setInnerContainerSize(CCSizeMake(scrollView:getSize().width,widgetHeight));	elseif style == "H" then 		scrollView:setDirection(SCROLLVIEW_DIR_HORIZONTAL)		scrollView:setInnerContainerSize(CCSizeMake(widgetWidth,scrollView:getSize().height));	endendfunction setButtonListenner(widgetTb,rootView,Handle_func)	local function handle_onClick(typeName,widget) 		if typeName == "releaseUp" then			for key,value in pairs(widgetTb) do	--取消原来两的东西				if value.isBright == true then 					local Sprite = value.widget:getVirtualRenderer()					tolua.cast(Sprite,"CCSprite")					Proxy:spriteHighlight(Sprite,false)						Handle_func(widget)				end 			end			value.isBright = true			local Sprite = widget:getVirtualRenderer()			tolua.cast(Sprite,"CCSprite")			Proxy:spriteHighlight(Sprite,true)				Handle_func(widget)		end	end	for key,value in pairs(widgetTb) do		if value.isBright == true then 			local Sprite = value.widget:getVirtualRenderer()			tolua.cast(Sprite,"CCSprite")			Proxy:spriteHighlight(Sprite,false)				Handle_func(widget)		end 		local Btn =  rootView:getWidgetByName(value.widget:getName())		weight:registerEventScript(handle_onClick)	endend--注意要释放local mJosnCaCheTb = {}-- josn Cachefunction LoadWidgetFromJsonFile(JosnFile)	--[[	local isLoaded = false 		for key,value in pairs(mJosnCaCheTb) do		--cclog("Key-----Json--------->", key ,type(key))		if key == JosnFile then 			isLoaded = true		end	end	local widget = nil	if isLoaded == false then		local newWidget = GUIReader:shareReader():widgetFromJsonFile(JosnFile)		mJosnCaCheTb[JosnFile] = newWidget		cclog("new JSON  ->",JosnFile)	 end	widget = mJosnCaCheTb[JosnFile]:clone()	mJosnCaCheTb[JosnFile]:retain()	]]--	local widget = GUIReader:shareReader():widgetFromJsonFile(JosnFile)	return widgetendfunction releasePreJson()	for key ,value in pairs(mJosnCaCheTb) do		if value ~= nil then 			value:release()			value = nil 		end 	end 	mJosnCaCheTb = nilend local FocusName = nil function initUIViewDate()	FocusName = nilend --设置 UITextView 闪动光标事件	--参数：TextField:当前UIWidetfunction setTextFieldFocus(TextField)	local MASK_LABEL = 330	--foucs Pos	local function setFocusPosition(TextField,label)		if  TextField:getStringValue()== "" then			label:setPosition(ccp(0 ,0 ))			--TextField:setPlaceHolder("")		else			label:setPosition( ccp(TextField:getContentSize().width/2 ,0))		end	end	--create focus	local function createFocus(TextField,key) 		if FocusName == TextField:getName() then  			return 		else				--clear focus			if FocusName ~= nil then 				local topUILayer = UIManager.findLayerByTag(UIManager.getTopLayerName())				local lastTextField = topUILayer:getRootWidget():getChildByName(FocusName)				if  lastTextField ~= nil then 					lastTextField:removeAllChildren()				end 			end						FocusName = TextField:getName()			 			label =UILabel:create()      --往里面添加好友说的话，   			label:setAnchorPoint(ccp(0.5,0.5))			setFocusPosition(TextField,label)			label:setFontSize(24)			label:setText("I")			label:setFontName("fzzdh.TTF")			label:setTextHorizontalAlignment(kCCTextAlignmentCenter) 			label:runAction(CCRepeatForever:create(CCBlink:create(7,8)))			label:setTag(MASK_LABEL)			TextField:addChild(label)		end	end	--callback handle	local function handleFocus(EventType,widget) 		if "attachWithIME" == EventType then			createFocus(widget)		elseif EventType == "insertText" or EventType == "deleteBackward" then 			local label = widget:getChildByTag(MASK_LABEL)			setFocusPosition(TextField,label)		elseif "detachWithIME" == EventType then			--[[if isPointAgain == false then 				local I = widget:getChildByTag(MASK_LABEL)				widget:removeAllChildren()			end			]]--		end	end	TextField:registerEventScript(handleFocus)	endfunction setLayoutGridView(LayoutView,ArrayDate,line)	local LayoutViewSize = LayoutView:getSize()		local pNext = 1	local iCount = 0		for key,widget in pairs(ArrayDate) do 		local widget_height = widget:getSize().height		local widget_width  = widget:getSize().width					local x,y = widget:getAnchorPoint()		if iCount < line then 				iCount = iCount + 1		else 			iCount = 1			pNext = pNext + 1		end						local detalX =  (LayoutViewSize.width - line* widget_width)/(line + 1)--向左偏移已至居中		widget:setPosition(ccp(widget_width*(iCount) - widget_width/2+detalX*iCount ,		LayoutViewSize.height - widget_height * pNext + widget:getAnchorPoint().y * widget_height))		LayoutView:addChild(widget)	endend--只支持竖方向下滑   --ArrayDate :widget表--line:纵列数--interval_height：高度间隔function setAdapterGridView(scrollView,ArrayDate,line,interval_height)	tolua.cast(scrollView,"UIScrollView")	local scrollViewSize = scrollView:getSize()	--deltaH 当前裁剪窗口可以容纳多少个View	local function getRightSize(length,deltaH) 		if (length/line) < deltaH then 			return  deltaH+1		end		if length % line == 0 then				return math.floor(length/line)+1	--偶数		else 			return math.floor(length/line)+1 +1	--奇数			--return length/line+1 +1	--奇数		end	end	local widgetHeight = 0	local pNext = 1	local iCount = 0	for key,widget in pairs(ArrayDate) do 		local widget_height = widget:getSize().height --+ interval_delta		local widget_width  = widget:getSize().width					widget:setAnchorPoint(ccp(0.5,0.5))		if iCount < line then 				iCount = iCount + 1		else 			iCount = 1			pNext = pNext + 1			widgetHeight  = pNext * widget:getSize().height		end		local detalX =  (scrollViewSize.width - line* widget_width)/(line + 1)--向左偏移已至居中			local deltaH =  scrollViewSize.height/widget_height		local finalx = widget_width*(iCount) - widget_width/2+detalX*iCount				local L = getRightSize(#ArrayDate,deltaH)		local finaly = widget_height*(L- pNext-1)+ widget_height/2 - interval_height*pNext + #ArrayDate/line*interval_height		if #ArrayDate % line == 0 then				widget:setPosition(ccp(finalx,finaly))		else			widget:setPosition(ccp(finalx,finaly + interval_height))		end						scrollView:addChild(widget)	end		scrollView:setBounceEnabled(true)	scrollView:setDirection(SCROLLVIEW_DIR_VERTICAL)	scrollView:setInnerContainerSize(CCSizeMake(scrollView:getSize().width,widgetHeight + (pNext)*interval_height ));		--[[	cclog("*************InnerContainerSize*************",scrollView:getInnerContainerSize().width,scrollView:getInnerContainerSize().height,			"widgetHeight",widgetHeight)	cclog("*************scrollViewSize*************",scrollView:getSize().width,scrollView:getSize().height)	]]--end--FIX line == 1 function setAdapter(scrollView,ArrayDate,line,interval,offsetX)	tolua.cast(scrollView,"UIScrollView")	scrollView:setDirection(SCROLLVIEW_DIR_VERTICAL)			local deltaWidget = math.floor(scrollView:getSize().height / ArrayDate[1]:getSize().height)	local pRet = false	if #ArrayDate < deltaWidget then 		pRet = true	else 		ArrayDate = CommonFunc_InvertedTable(ArrayDate)	end 	local widgetHeight = 0	local pNext = 1	  --表示 竖方向	local iCount = 0  --表示 横方向	for key,widget in pairs(ArrayDate) do 		local widget_width = widget:getSize().width		local widget_height = widget:getSize().height 		--widget:setAnchorPoint(ccp(0,0))		if iCount < line then 				iCount = iCount + 1		else 			iCount = 1			pNext = pNext + 1			widgetHeight  = pNext * widget_height + interval*(pNext-1)		end				local finalx = widget_width/2+(iCount-1)*widget_width + offsetX		local finaly = widget_height*(pNext-1)+ widget_height/2 + interval*(pNext-1)		if pRet == true then 			finaly = scrollView:getSize().height - finaly		end		widget:setPosition(ccp(finalx,finaly))				scrollView:addChild(widget)	end			scrollView:setInnerContainerSize(CCSizeMake(scrollView:getSize().width,widgetHeight))end